"""
Synchronization module
======================

This module provides functions to process the synchronization data
acquired with Thor Sync during imaging.
"""

import numpy as np
import h5py
import json

from .errors import SynchronizationError


def get_lines_from_h5_file(file_path, line_names):
    """
    This function returns the values of the requested lines save in
    an h5 generated by ThorSync.

    Parameters
    ----------
    file_path : string
        Path to h5 file.
    line_names : list of strings
        List of the ThorSync line names to be returned.

    Returns
    -------
    lines : tuple
        Line arrays in the same order as given in line_names.
    """
    f = h5py.File(file_path, "r")
    lines = []
    for name in line_names:
        try:
            lines.append(f["DI"][name][:].squeeze())
        except KeyError:
            lines.append(f["CI"][name][:].squeeze())
    return tuple(lines)


def get_times(length, freq):
    """
    This function returns the time point of each tick
    for a given sequence length and tick frequency.

    Parameters
    ----------
    length : int
        Length of sequence.
    freq : float
        Frequency in Hz.

    Returns
    -------
    times : array
        Times in seconds.
    """
    times = np.arange(0, length / freq, 1 / freq)
    assert len(times) == length
    return times


def edges(line, size=0):
    """
    Returns the indices of an edges in a line with
    a specific size.

    Parameters
    ----------
    line : numpy array
        Line signal from h5 file.
    size : float or tuple
        Size of the rising edge. If float it is used as minimum.
        Tuples specify a range. To get falling edges use negative values.
        Only one boundary can be applied using np.inf as on of the values.

    Returns
    -------
    indices : list
        Indices of the rising edges.
    """
    diff = np.diff(line.astype(np.float64))
    if type(size) == tuple:
        indices = np.where(np.logical_and(diff > size[0], diff < size[1]))
    else:
        indices = np.where(diff > size)
    indices = tuple([i + 1 for i in indices])
    return indices


def get_start_times(line, times):
    """
    Get the start times of a digital signal,
    i.e. the times of the rising edges.

    Parameters
    ----------
    line : numpy array
        Line signal from h5 file.
    times : numpy array
        Times returned by :func:`new_synchronization.get_times`

    Returns
    -------
    time_points : list
        List of the start times.
    """
    indices = edges(line, size=(0, np.inf))
    time_points = times[indices]
    return time_points


def process_cam_line(line, capture_json):
    """
    Remove superfluous signals and use frame numbers in array.

    Parameters
    ----------
    line : numpy array
        Line signal from h5 file.
    capture_json : string
        Path to the json file save by our camera software.
        This file is usually located in the same folder as the frames
        and is called 'capture_metadata.json'. If None, it is assumed
        that no frames were dropped.

    Returns
    -------
    processed_line : numpy array
        Array with frame number for each time point.
        If no frame is available for a given time the value is -1.
    """
    rising_edges = edges(line, (0, np.inf))[0]

    if capture_json is not None:
        with open(capture_json, "r") as f:
            capture_info = json.load(f)
    else:
        frames_dict = {}
        for i in range(len(rising_edges)):
            frames_dict[str(i)] = i
        capture_info = {"Frame Counts": {"0": frames_dict}}
    last_ticks = []

    for cam_idx in capture_info["Frame Counts"].keys():
        last_ticks.append(max(capture_info["Frame Counts"][cam_idx].values()))

    last_tick = max(last_ticks)
    if len(np.unique(last_ticks)) > 1:
        raise SynchronizationError("The frames across cameras are not synchronized.")

    processed_line = np.ones_like(line) * -1

    current_frame = 0
    first_camera_used = sorted(list(capture_info["Frame Counts"].keys()))[0]
    # plus 1 because the json file start counting from 0
    for i, (start, stop) in enumerate(
        zip(rising_edges[: last_tick + 1], rising_edges[1 : last_tick + 2])
    ):
        if capture_info["Frame Counts"][first_camera_used][str(current_frame + 1)] <= i:
            current_frame += 1
        processed_line[start:stop] = current_frame
    return processed_line.astype(np.int)


def process_frame_counter(line, steps_per_frame=1):
    """
    Converts the frame counter line to an array with frame numbers for each
    time point.

    Parameters
    ----------
    line : numpy array
        Line signal from h5 file.
    steps_per_frame : int
        Number of steps the frame counter takes per frame.
        This includes fly back frame, i.e. if you acquire one frame
        and flyback frames is set to 3 this number should be 4.

    Returns
    -------
    processed_frame_counter : numpy array
        Array with frame number for each time point.
        If no frame was recorded at a time point the value is -1.
    """
    processed_frame_counter = np.ones_like(line) * -1
    rising_edges = edges(line, (0, np.inf))[0]
    for i, index in enumerate(
        range(0, len(rising_edges) - steps_per_frame, steps_per_frame)
    ):
        processed_frame_counter[
            rising_edges[index] : rising_edges[index + steps_per_frame]
        ] = i
    processed_frame_counter[rising_edges[-steps_per_frame] :] = (
        processed_frame_counter[rising_edges[-steps_per_frame] - 1] + 1
    )
    return processed_frame_counter.astype(np.int)


def process_stimulus_line(line):
    """
    This function converts the stimulus line to an array with
    0s and 1s for stimulus off and on respectively.

    Parameters
    ----------
    line : numpy array
        Line signal from h5 file.

    Returns
    -------
    processed_frame_counter : numpy array
        Array with binary stimulus state for each time point.
    """
    processed_stimulus_line = np.zeros_like(line)
    indices = np.where(line > 0)
    processed_stimulus_line[indices] = 1
    return processed_stimulus_line.astype(np.int)


def crop_lines(mask, lines):
    """
    This function crops all lines based on a binary signal/mask.
    The 'Capture On' line of the h5 file can be used as a mask.

    Parameters
    ----------
    mask : numpy array
        Mask that is used for cropping.
    lines : list of numpy arrays
        List of the lines that should be cropped.

    Returns
    -------
    cropped_lines : tuple of numpy arrays
        Tuple of cropped lines in same order as in input list.
    """
    indices = np.where(mask)[0]
    first_idx = indices[0]
    last_idx = indices[-1]
    cropped_lines = []
    for line in lines:
        cropped_lines.append(line[first_idx : last_idx + 1])
    return tuple(cropped_lines)


def beh_idx_to_2p_idx(beh_indices, cam_line, frame_counter):
    """
    This functions converts behaviour frame numbers into the corresponding
    2p frame numbers.

    Parameters
    ----------
    beh_indices : numpy array
        Indices of the behaviour frames to be converted.
    cam_line : numpy array
        Processed cam line.
    frame_counter : numpy array
        Processed frame counter.

    Returns
    -------
    indices_2p : numpy array
        Corresponding 2p frame indices.
    """
    thor_sync_indices = np.where(np.diff(cam_line))[0][1:] + 1

    indices_2p = np.ones(len(beh_indices), dtype=np.int) * -1

    for i, frame_num in enumerate(beh_indices):
        thor_sync_index = thor_sync_indices[frame_num]
        beh_frame_num = cam_line[thor_sync_index]
        indices_2p[i] = frame_counter[thor_sync_index]

    return indices_2p.astype(np.int)


def reduce_during_2p_frame(frame_counter, values, function):
    """
    Reduces all values occuring during the acquisition of a
    2-photon frame to a single value using the `function`
    given by the user.

    Parameters
    ----------
    frame_counter : numpy array
        Processed frame counter.
    values : numpy array
        Values upsampled to the frequency of ThorSync,
        i.e. 1D numpy array of the same length as
        `frame_counter`.
    function : function
        Function used to reduce the value,
        e.g. np.mean.

    Returns
    -------
    reduced : numpy array
        Numpy array with value for each 2p frame.
    """
    if len(frame_counter) != len(values):
        raise ValueError("frame_counter and values need to have the same length.")
    
    reduced = np.ones(np.max(frame_counter) + 1) * np.nan
    thor_sync_indices = tuple(edges(frame_counter, (0, np.inf))[0])
    
    starts = thor_sync_indices
    stops = thor_sync_indices[1:] + (len(frame_counter),)
    
    if frame_counter[0] != -1:
        starts = (0,) + starts
        stops = (thor_sync_indices[0],) + stops

    for i, (start, stop) in enumerate(zip(starts, stops)):
        reduced[i] = function(values[start:stop])

    return reduced
