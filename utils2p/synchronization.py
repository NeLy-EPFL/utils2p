"""
Synchronization module
======================

This module provides functions to process the synchronization data
acquired with Thor Sync during imaging.
"""

import numpy as np
import h5py
import json

from .errors import SynchronizationError


def get_lines_from_h5_file(file_path, line_names):
    """
    This function returns the values of the requested lines save in
    an h5 generated by ThorSync.

    Parameters
    ----------
    file_path : string
        Path to h5 file.
    line_names : list of strings
        List of the ThorSync line names to be returned.

    Returns
    -------
    lines : tuple
        Line arrays in the same order as given in line_names.
    """
    lines = []
    
    with h5py.File(file_path, "r") as f:
        for name in line_names:
            try:
                lines.append(f["DI"][name][:].squeeze())
            except KeyError:
                lines.append(f["CI"][name][:].squeeze())
    return tuple(lines)


def get_times(length, freq):
    """
    This function returns the time point of each tick
    for a given sequence length and tick frequency.

    Parameters
    ----------
    length : int
        Length of sequence.
    freq : float
        Frequency in Hz.

    Returns
    -------
    times : array
        Times in seconds.
    """
    times = np.arange(0, length / freq, 1 / freq)
    return times


def edges(line, size=0):
    """
    Returns the indices of an edges in a line with
    a specific size.

    Parameters
    ----------
    line : numpy array
        Line signal from h5 file.
    size : float or tuple
        Size of the rising edge. If float it is used as minimum.
        Tuples specify a range. To get falling edges use negative values.
        Only one boundary can be applied using np.inf as on of the values.

    Returns
    -------
    indices : list
        Indices of the rising edges.
    """
    diff = np.diff(line.astype(np.float64))
    if type(size) == tuple:
        indices = np.where(np.logical_and(diff > size[0], diff < size[1]))
    else:
        indices = np.where(diff > size)
    indices = tuple([i + 1 for i in indices])
    return indices


def get_start_times(line, times):
    """
    Get the start times of a digital signal,
    i.e. the times of the rising edges.

    Parameters
    ----------
    line : numpy array
        Line signal from h5 file.
    times : numpy array
        Times returned by :func:`new_synchronization.get_times`

    Returns
    -------
    time_points : list
        List of the start times.
    """
    indices = edges(line, size=(0, np.inf))
    time_points = times[indices]
    return time_points


def _default_capture_metadata(n_frames):
    """
    Returns a dictionary as it is usually saved by the seven
    camera setup in the "capture_metadata.json" file.
    It assumes that no frames where dropped.

    Parameters
    ----------
    n_frames : int
        Number of frames.

    Returns
    -------
    capture_info : dict
        Default metadata dictionary for the seven camera
        system.
    """
    frames_dict = {}
    for i in range(n_frames):
        frames_dict[str(i)] = i
    capture_info = {"Frame Counts": {"0": frames_dict}}
    return capture_info


def process_cam_line(line, capture_json):
    """
    Remove superfluous signals and use frame numbers in array.
    The cam line signal form the h5 file is a binary sequence.
    Rising edges mark the acquisition of a new frame.
    The setup keeps producing rising edges after the acquisition of the
    last frame. These rising edges are ignored.
    This function converts it to frame numbers using the information
    stored in the metadata file of the seven camera setup.
    In the metadata file the keys are the indices of the file names
    and the values are the grabbed frame numbers. Suppose the 3
    frame was dropped. Then the entries in the dictionary will
    be as follows:
    "2": 2
    "3": 4
    "4": 5

    Parameters
    ----------
    line : numpy array
        Line signal from h5 file.
    capture_json : string
        Path to the json file save by our camera software.
        This file is usually located in the same folder as the frames
        and is called 'capture_metadata.json'. If None, it is assumed
        that no frames were dropped.

    Returns
    -------
    processed_line : numpy array
        Array with frame number for each time point.
        If no frame is available for a given time the value is -1.
    """
    # Check that sequence is binary
    if len(set(line)) > 2:
        raise ValueError("Invalid line argument. Sequence is not binary.")

    # Find indices of the start of each frame acquisition
    rising_edges = edges(line, (0, np.inf))[0]

    # Load capture metadata or generate default
    if capture_json is not None:
        with open(capture_json, "r") as f:
            capture_info = json.load(f)
    else:
        capture_info = _default_capture_metadata(len(rising_edges))

    # Find the number of frames for each camera
    n_frames = []
    for cam_idx in capture_info["Frame Counts"].keys():
        max_in_json = max(capture_info["Frame Counts"][cam_idx].values())
        n_frames.append(max_in_json + 1)

    # Ensure all cameras acquired the same number of frames
    if len(np.unique(n_frames)) > 1:
        raise SynchronizationError("The frames across cameras are not synchronized.")

    # Last rising edge that corresponds to a frame
    last_tick = max(n_frames)

    # check that there is a rising edge for every frame
    if len(rising_edges) < last_tick:
        raise ValueError("The provided cam line and metadata are inconsistent. cam line has less frame acquisitions than metadata.")

    # Ensure correct handling if no rising edges are present after last frame
    if len(rising_edges) == int(last_tick):
        average_frame_length = int(np.mean(np.diff(rising_edges)))
        last_rising_edge = rising_edges[-1]
        additional_edge = last_rising_edge + average_frame_length
        if additional_edge > len(line):
            additional_edge = len(line)
        rising_edges = list(rising_edges)
        rising_edges.append(additional_edge)
        rising_edges = np.array(rising_edges)

    processed_line = np.ones_like(line) * -1

    current_frame = 0
    first_camera_used = sorted(list(capture_info["Frame Counts"].keys()))[0]
    for i, (start, stop) in enumerate(
        zip(rising_edges[: last_tick], rising_edges[1 : last_tick + 1])
    ):
        if capture_info["Frame Counts"][first_camera_used][str(current_frame + 1)] <= i:
            current_frame += 1
        processed_line[start:stop] = current_frame
    return processed_line.astype(np.int)


def process_frame_counter(line, steps_per_frame=1):
    """
    Converts the frame counter line to an array with frame numbers for each
    time point.

    Parameters
    ----------
    line : numpy array
        Line signal from h5 file.
    steps_per_frame : int
        Number of steps the frame counter takes per frame.
        This includes fly back frame, i.e. if you acquire one frame
        and flyback frames is set to 3 this number should be 4.

    Returns
    -------
    processed_frame_counter : numpy array
        Array with frame number for each time point.
        If no frame was recorded at a time point the value is -1.
    """
    processed_frame_counter = np.ones_like(line) * -1
    rising_edges = edges(line, (0, np.inf))[0]
    for i, index in enumerate(
        range(0, len(rising_edges) - steps_per_frame, steps_per_frame)
    ):
        processed_frame_counter[
            rising_edges[index] : rising_edges[index + steps_per_frame]
        ] = i
    processed_frame_counter[rising_edges[-steps_per_frame] :] = (
        processed_frame_counter[rising_edges[-steps_per_frame] - 1] + 1
    )
    return processed_frame_counter.astype(np.int)


def process_stimulus_line(line):
    """
    This function converts the stimulus line to an array with
    0s and 1s for stimulus off and on respectively.

    Parameters
    ----------
    line : numpy array
        Line signal from h5 file.

    Returns
    -------
    processed_frame_counter : numpy array
        Array with binary stimulus state for each time point.
    """
    processed_stimulus_line = np.zeros_like(line)
    indices = np.where(line > 0)
    processed_stimulus_line[indices] = 1
    return processed_stimulus_line.astype(np.int)


def process_optical_flow_line(line):
    """
    This function converts the optical flow line
    into a step function. The value corresponds
    to the index of optical flow value at this
    time point. If the value is -1, no optical flow
    value was recorded for this time point.

    Parameters
    ----------
    line : numpy array
        Line signal for h5 file.

    Returns
    -------
    processed_optical_flow_line : numpy array
        Array with monotonically increasing step
        function.
    """
    processed_optical_flow_line = np.ones_like(line) * -1
    rising_edges = edges(line, (0, np.inf))[0]
    for i in range(0, len(rising_edges) - 1):
        processed_optical_flow_line[
            rising_edges[i] : rising_edges[i + 1]
        ] = i
    processed_optical_flow_line[rising_edges[-1] :] = (
        processed_optical_flow_line[rising_edges[-1] - 1] + 1
    )
    return processed_optical_flow_line.astype(np.int)


def crop_lines(mask, lines):
    """
    This function crops all lines based on a binary signal/mask.
    The 'Capture On' line of the h5 file can be used as a mask.

    Parameters
    ----------
    mask : numpy array
        Mask that is used for cropping.
    lines : list of numpy arrays
        List of the lines that should be cropped.

    Returns
    -------
    cropped_lines : tuple of numpy arrays
        Tuple of cropped lines in same order as in input list.
    """
    indices = np.where(mask)[0]
    first_idx = indices[0]
    last_idx = indices[-1]
    cropped_lines = []
    for line in lines:
        cropped_lines.append(line[first_idx : last_idx + 1])
    return tuple(cropped_lines)


def beh_idx_to_2p_idx(beh_indices, cam_line, frame_counter):
    """
    This functions converts behaviour frame numbers into the corresponding
    2p frame numbers.

    Parameters
    ----------
    beh_indices : numpy array
        Indices of the behaviour frames to be converted.
    cam_line : numpy array
        Processed cam line.
    frame_counter : numpy array
        Processed frame counter.

    Returns
    -------
    indices_2p : numpy array
        Corresponding 2p frame indices.
    """
    thor_sync_indices = edges(cam_line)[0]

    indices_2p = np.ones(len(beh_indices), dtype=np.int) * -1

    for i, frame_num in enumerate(beh_indices):
        thor_sync_index = thor_sync_indices[frame_num]
        beh_frame_num = cam_line[thor_sync_index]
        indices_2p[i] = frame_counter[thor_sync_index]

    return indices_2p.astype(np.int)


def reduce_during_2p_frame(frame_counter, values, function):
    """
    Reduces all values occuring during the acquisition of a
    2-photon frame to a single value using the `function`
    given by the user.

    Parameters
    ----------
    frame_counter : numpy array
        Processed frame counter.
    values : numpy array
        Values upsampled to the frequency of ThorSync,
        i.e. 1D numpy array of the same length as
        `frame_counter`.
    function : function
        Function used to reduce the value,
        e.g. np.mean.

    Returns
    -------
    reduced : numpy array
        Numpy array with value for each 2p frame.
    """
    if len(frame_counter) != len(values):
        raise ValueError("frame_counter and values need to have the same length.")
    
    reduced = np.ones(np.max(frame_counter) + 1) * np.nan
    thor_sync_indices = tuple(edges(frame_counter, (0, np.inf))[0])
    
    starts = thor_sync_indices
    stops = thor_sync_indices[1:] + (len(frame_counter),)
    
    if frame_counter[0] != -1:
        starts = (0,) + starts
        stops = (thor_sync_indices[0],) + stops

    for i, (start, stop) in enumerate(zip(starts, stops)):
        reduced[i] = function(values[start:stop])

    return reduced
