
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>utils2p.main &#8212; utils2p  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" href="../../_static/css/functions.css" type="text/css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for utils2p.main</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Core module</span>
<span class="sd">===========</span>

<span class="sd">The functions in this module are essentials that can be directly imported using `import utils2p`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>
<span class="kn">import</span> <span class="nn">array</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.external</span> <span class="kn">import</span> <span class="n">tifffile</span>

<span class="n">package_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">InvalidValueInMetaData</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This error should be raised when an invalid value</span>
<span class="sd">    is encountered in an &#39;Experiement.xml&#39; file.&quot;&quot;&quot;</span>

    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">_node_crawler</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hit dead end </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2"> has no children.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_node_crawler</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>


<span class="k">class</span> <span class="nc">_XMLFile</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for xml based Metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_node_crawler</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">values</span>


<div class="viewcode-block" id="Metadata"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata">[docs]</a><span class="k">class</span> <span class="nc">Metadata</span><span class="p">(</span><span class="n">_XMLFile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for managing ThorImage metadata.</span>
<span class="sd">    Loads metadata file &#39;Experiment.xml&#39; and returns the root of an ElementTree.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : string</span>
<span class="sd">        Path to xml file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Instance of class Metadata</span>
<span class="sd">        Based on given xml file.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; metadata = utils2p.Metadata(&quot;data/mouse_kidney_z_stack/Experiment.xml&quot;)</span>
<span class="sd">    &gt;&gt;&gt; type(metadata)</span>
<span class="sd">    &lt;class &#39;utils2p.main.Metadata&#39;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Metadata.get_metadata_value"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_metadata_value">[docs]</a>    <span class="k">def</span> <span class="nf">get_metadata_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns a value from the metadata file &#39;Experiment.xml&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : strings</span>
<span class="sd">            Arbitrary number of strings of tags from the xml file in the</span>
<span class="sd">            correct order. See examples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        attribute or node : string or ElementTree node</span>
<span class="sd">            If the number of strings given in args leads to a leaf of the tree,</span>
<span class="sd">            the attribute, usually a dictionary, is returned.</span>
<span class="sd">            Otherwise the node is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_metadata_value(&#39;Timelapse&#39;,&#39;timepoints&#39;)</span>
<span class="sd">        &#39;3&#39;</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_metadata_value(&#39;LSM&#39;,&#39;pixelX&#39;)</span>
<span class="sd">        &#39;128&#39;</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_metadata_value(&#39;LSM&#39;,&#39;pixelY&#39;)</span>
<span class="sd">        &#39;128&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="Metadata.get_n_time_points"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_n_time_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_n_time_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of time points for a given experiment metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_time_points : int</span>
<span class="sd">            Number of time points.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_n_time_points()</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;Timelapse&quot;</span><span class="p">,</span> <span class="s2">&quot;timepoints&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_num_x_pixels"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_num_x_pixels">[docs]</a>    <span class="k">def</span> <span class="nf">get_num_x_pixels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the image width for a given experiment metadata,</span>
<span class="sd">        i.e. the number of pixels in the x direction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        width : int</span>
<span class="sd">            Width of image.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_num_x_pixels()</span>
<span class="sd">        128</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;LSM&quot;</span><span class="p">,</span> <span class="s2">&quot;pixelX&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_num_y_pixels"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_num_y_pixels">[docs]</a>    <span class="k">def</span> <span class="nf">get_num_y_pixels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the image height for a given experiment metadata,</span>
<span class="sd">        i.e. the number of pixels in the y direction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        height : int</span>
<span class="sd">            Width of image.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_num_y_pixels()</span>
<span class="sd">        128</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;LSM&quot;</span><span class="p">,</span> <span class="s2">&quot;pixelY&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_area_mode"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_area_mode">[docs]</a>    <span class="k">def</span> <span class="nf">get_area_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the area mode of a given experiment metadata, e.g.</span>
<span class="sd">        square, rectangle, line, kymograph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        area_mode : string</span>
<span class="sd">            Area mode of experiment.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_area_mode()</span>
<span class="sd">        &#39;square&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">int_area_mode</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;LSM&quot;</span><span class="p">,</span> <span class="s2">&quot;areaMode&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">int_area_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;square&quot;</span>
        <span class="k">if</span> <span class="n">int_area_mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;rectangle&quot;</span>
        <span class="k">if</span> <span class="n">int_area_mode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;kymograph&quot;</span>
        <span class="k">if</span> <span class="n">int_area_mode</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;line&quot;</span>
        <span class="k">raise</span> <span class="n">InvalidValueInMetaData</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">int_area_mode</span><span class="si">}</span><span class="s2"> is not a valid value for areaMode.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Metadata.get_n_z"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_n_z">[docs]</a>    <span class="k">def</span> <span class="nf">get_n_z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number for z slices for a given experiment metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_z : int</span>
<span class="sd">            Number of z layers of image.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_n_z()</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;ZStage&quot;</span><span class="p">,</span> <span class="s2">&quot;steps&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_n_averaging"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_n_averaging">[docs]</a>    <span class="k">def</span> <span class="nf">get_n_averaging</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of frames that are averaged.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_averaging : int</span>
<span class="sd">            Number of averaged frames.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_n_averaging()</span>
<span class="sd">        10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;LSM&quot;</span><span class="p">,</span> <span class="s2">&quot;averageNum&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_n_channels"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_n_channels">[docs]</a>    <span class="k">def</span> <span class="nf">get_n_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of channels for a given experiment metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_channels : int</span>
<span class="sd">            Number of channels in raw data file.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_n_channels()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;Wavelengths&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Metadata.get_channels"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_channels">[docs]</a>    <span class="k">def</span> <span class="nf">get_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple with the names of all channels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        channels : tuple of strings</span>
<span class="sd">            Names of channels.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_channels()</span>
<span class="sd">        (&#39;ChanA&#39;, &#39;ChanB&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;Wavelengths&quot;</span><span class="p">,</span> <span class="s2">&quot;Wavelength&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span></div>

<div class="viewcode-block" id="Metadata.get_pixel_size"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_pixel_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_pixel_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the pixel size for a given experiment metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pixel_size : float</span>
<span class="sd">            Size of one pixel in um in x and y direction.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_pixel_size()</span>
<span class="sd">        0.593</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;LSM&quot;</span><span class="p">,</span> <span class="s2">&quot;pixelSizeUM&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_z_step_size"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_z_step_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_z_step_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the z step size for a given experiment metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        z_step_size : float</span>
<span class="sd">            Distance covered in um along z direction.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_z_step_size()</span>
<span class="sd">        15.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;ZStage&quot;</span><span class="p">,</span> <span class="s2">&quot;stepSizeUM&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_z_pixel_size"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_z_pixel_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_z_pixel_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the pixel size in z direction for a given experiment metadata.</span>
<span class="sd">        This function is meant for &quot;kymograph&quot; and &quot;line&quot; recordings.</span>
<span class="sd">        For these recordings the pixel size in z direction is not </span>
<span class="sd">        equal to the step size, unless the number of pixels equals the number</span>
<span class="sd">        of steps.</span>
<span class="sd">        For all other types of recordings it is equivalent to :func:`get_z_step_size`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        z_pixel_size : float</span>
<span class="sd">            Distance covered in um along z direction.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_z_pixel_size()</span>
<span class="sd">        15.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">area_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_mode</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">area_mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;kymograph&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;ZStage&quot;</span><span class="p">,</span> <span class="s2">&quot;stepSizeUM&quot;</span><span class="p">))</span> <span class="o">*</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_n_z</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_y_pixels</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;ZStage&quot;</span><span class="p">,</span> <span class="s2">&quot;stepSizeUM&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_dwell_time"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_dwell_time">[docs]</a>    <span class="k">def</span> <span class="nf">get_dwell_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the dwell time for a given experiment metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dwell_time : float</span>
<span class="sd">            Dwell time for a pixel.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_dwell_time()</span>
<span class="sd">        0.308199306062498</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;LSM&quot;</span><span class="p">,</span> <span class="s2">&quot;dwellTime&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_n_flyback_frames"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_n_flyback_frames">[docs]</a>    <span class="k">def</span> <span class="nf">get_n_flyback_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of flyback frames.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_flyback : int</span>
<span class="sd">            Number of flyback frames.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_flyback</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;Streaming&quot;</span><span class="p">,</span> <span class="s2">&quot;flybackFrames&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">n_flyback</span></div>

<div class="viewcode-block" id="Metadata.get_frame_rate"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_frame_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_frame_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the frame rate for a given experiment metadata.</span>
<span class="sd">        When the frame rate is calculated flyback frames and</span>
<span class="sd">        steps in z are not considered frames.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        frame_rate : float</span>
<span class="sd">            Frame rate of the experiment.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_frame_rate()</span>
<span class="sd">        10.0145</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frame_rate_without_flybacks</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;LSM&quot;</span><span class="p">,</span> <span class="s2">&quot;frameRate&quot;</span><span class="p">))</span>
        <span class="n">flyback_frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_flyback_frames</span><span class="p">()</span>
        <span class="n">number_of_slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_z</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">frame_rate_without_flybacks</span> <span class="o">/</span> <span class="p">(</span><span class="n">flyback_frames</span> <span class="o">+</span>
                                              <span class="n">number_of_slices</span><span class="p">)</span></div>

<div class="viewcode-block" id="Metadata.get_width"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_width">[docs]</a>    <span class="k">def</span> <span class="nf">get_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the image width in um for a given experiment metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        width : float</span>
<span class="sd">            Width of FOV in um..</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_width()</span>
<span class="sd">        75.88</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;LSM&quot;</span><span class="p">,</span> <span class="s2">&quot;widthUM&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_power_reg1_start"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_power_reg1_start">[docs]</a>    <span class="k">def</span> <span class="nf">get_power_reg1_start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the starting position of power regulator 1 for a given</span>
<span class="sd">        experiment metadata. Unless a gradient is defined, this</span>
<span class="sd">        value is the power value for the entire experiment.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reg1_start : float</span>
<span class="sd">            Starting position of power regulator 1.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_power_reg1_start()</span>
<span class="sd">        1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;PowerRegulator&quot;</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_gain_a"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_gain_a">[docs]</a>    <span class="k">def</span> <span class="nf">get_gain_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the gain of channel A for a given experiment metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gainA : int</span>
<span class="sd">            Gain of channel A.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_gain_a()</span>
<span class="sd">        20.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;PMT&quot;</span><span class="p">,</span> <span class="s2">&quot;gainA&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_gain_b"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_gain_b">[docs]</a>    <span class="k">def</span> <span class="nf">get_gain_b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the gain of channel B for a given experiment metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gainB : int</span>
<span class="sd">            Gain of channel B.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_gain_b()</span>
<span class="sd">        30.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;PMT&quot;</span><span class="p">,</span> <span class="s2">&quot;gainB&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Metadata.get_date_time"><a class="viewcode-back" href="../../metadata.html#utils2p.Metadata.get_date_time">[docs]</a>    <span class="k">def</span> <span class="nf">get_date_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the date and time of an experiment</span>
<span class="sd">        for a given experiment metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        date_time : string</span>
<span class="sd">            Date and time of an experiment.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p</span>
<span class="sd">        &gt;&gt;&gt; metadata = Metadata(&#39;data/mouse_kidney_time_series_z_stack/Experiment.xml&#39;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_date_time()</span>
<span class="sd">        &#39;11/21/2019 11:15:18&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_value</span><span class="p">(</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span> <span class="s2">&quot;date&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="load_img"><a class="viewcode-back" href="../../load_save.html#utils2p.load_img">[docs]</a><span class="k">def</span> <span class="nf">load_img</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">memmap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This functions loads an image from file and returns as a numpy array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : string</span>
<span class="sd">        Path to image file.</span>
<span class="sd">    memmap : bool</span>
<span class="sd">        If `True`, the image is not loaded into memory but remains on</span>
<span class="sd">        disk and a `numpy.memmap` object is returned. It can be indexed</span>
<span class="sd">        like a normal `numpy.array`. This option is useful when a stack</span>
<span class="sd">        does not fit into memory. It can also be used when opening many</span>
<span class="sd">        stacks simultaneously.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.array or numpy.memmap</span>
<span class="sd">        Image in form of numpy array or numpy memmap.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; img = utils2p.load_img(&quot;data/chessboard_GRAY_U16.tif&quot;)</span>
<span class="sd">    &gt;&gt;&gt; type(img)</span>
<span class="sd">    &lt;class &#39;numpy.ndarray&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; img.shape</span>
<span class="sd">    (200, 200)</span>
<span class="sd">    &gt;&gt;&gt; img = utils2p.load_img(&quot;data/chessboard_GRAY_U16.tif&quot;, memmap=True)</span>
<span class="sd">    &gt;&gt;&gt; type(img)</span>
<span class="sd">    &lt;class &#39;numpy.memmap&#39;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expandvars</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tifffile</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">memmap</span><span class="o">=</span><span class="n">memmap</span><span class="p">)</span></div>


<div class="viewcode-block" id="load_stack_batches"><a class="viewcode-back" href="../../load_save.html#utils2p.load_stack_batches">[docs]</a><span class="k">def</span> <span class="nf">load_stack_batches</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function loads a stack in several batches to make sure</span>
<span class="sd">    the system does not run out of memory. It returns a generator</span>
<span class="sd">    that yields consecutive chunks of `batch_size` frames of the stack.</span>
<span class="sd">    The remaining memory is freed up by the function until the generator</span>
<span class="sd">    is called again.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : string</span>
<span class="sd">        Path to stack.</span>
<span class="sd">    batch_size : int</span>
<span class="sd">        Number of frames in one chunk.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    generator</span>
<span class="sd">        Generator that yields chunks of `batch_size` frames of the</span>
<span class="sd">        stack.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">load_img</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">memmap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stack</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The path does not point to a stack. The shape is </span><span class="si">{</span><span class="n">stack</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="n">n_batches</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">batch_size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_batches</span><span class="p">):</span>
        <span class="n">substack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">])</span>
        <span class="k">yield</span> <span class="n">substack</span></div>


<div class="viewcode-block" id="load_stack_patches"><a class="viewcode-back" href="../../load_save.html#utils2p.load_stack_patches">[docs]</a><span class="k">def</span> <span class="nf">load_stack_patches</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a generator that yields patches of the stack of images.</span>
<span class="sd">    This is useful when multiple stacks should be processed but they</span>
<span class="sd">    don&#39;t fit into memory, e.g. when computing an overall fluorescence</span>
<span class="sd">    baseline for all trials of a fly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : string</span>
<span class="sd">       Path to stack.</span>
<span class="sd">    patch_size : tuple of two integers</span>
<span class="sd">       Size of the patch returned.</span>
<span class="sd">    padding : integer or tuple of two integers</span>
<span class="sd">       The amount of overlap between patches. Note that this increases</span>
<span class="sd">       the effective patch size. Default is 0. If tuple, different padding</span>
<span class="sd">       is used for the dimensions.</span>
<span class="sd">    return_indices : boolean</span>
<span class="sd">       If True, the indices necessary for slicing to generate the patch and</span>
<span class="sd">       the indices necessary for slicing to remove the padding from the</span>
<span class="sd">       returned patch are returned. Default is False.</span>
<span class="sd">       The values are retuned in the following form:</span>
<span class="sd">       ```</span>
<span class="sd">       indices = [[start_patch_dim_0, stop_patch_dim_0],</span>
<span class="sd">                 [start_patch_dim_1, stop_patch_dim_1],]</span>
<span class="sd">       patch_indices = [[start_after_padding_dim_0, stop_after_padding_dim_0],</span>
<span class="sd">                        [start_after_padding_dim_1, stop_after_padding_dim_1],]</span>
<span class="sd">       ```</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    patch : numpy array</span>
<span class="sd">        Patch of the stack.</span>
<span class="sd">    indices : tuples of integers, optional</span>
<span class="sd">        See description of the `return_indices` parameter above</span>
<span class="sd">        and examples below.</span>
<span class="sd">    patch_indices : tuples of integers, optinal</span>
<span class="sd">        See description of the `return_indices` parameter above</span>
<span class="sd">        and examples below.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; metadata = utils2p.Metadata(&#39;data/mouse_kidney_raw/2p/Untitled_001/Experiment.xml&#39;)</span>
<span class="sd">    &gt;&gt;&gt; stack1, stack2 = utils2p.load_raw(&#39;data/mouse_kidney_raw/2p/Untitled_001/Image_0001_0001.raw&#39;,metadata)</span>
<span class="sd">    &gt;&gt;&gt; print(stack1.shape)</span>
<span class="sd">    (5, 256, 256)</span>
<span class="sd">    &gt;&gt;&gt; utils2p.save_img(&#39;stack1.tif&#39;,stack1)</span>
<span class="sd">    &gt;&gt;&gt; generator = utils2p.load_stack_patches(&#39;stack1.tif&#39;, (5, 4))</span>
<span class="sd">    &gt;&gt;&gt; first_patch = next(generator)</span>
<span class="sd">    &gt;&gt;&gt; print(first_patch.shape)</span>
<span class="sd">    (5, 5, 4)</span>
<span class="sd">    &gt;&gt;&gt; generator = utils2p.load_stack_patches(&#39;stack1.tif&#39;, (15, 20), padding=3, return_indices=True)</span>
<span class="sd">    &gt;&gt;&gt; first_patch, indices, patch_indices = next(generator)</span>
<span class="sd">    &gt;&gt;&gt; print(first_patch.shape)</span>
<span class="sd">    (5, 18, 23)</span>
<span class="sd">    &gt;&gt;&gt; print(patch_indices)</span>
<span class="sd">    [[0, 15], [0, 20]]</span>
<span class="sd">    &gt;&gt;&gt; print(indices)</span>
<span class="sd">    [[0, 15], [0, 20]]</span>
<span class="sd">    &gt;&gt;&gt; first_patch_without_padding = first_patch[:, patch_indices[0][0] : patch_indices[0][1], patch_indices[1][0] : patch_indices[1][1]]</span>
<span class="sd">    &gt;&gt;&gt; print(first_patch_without_padding.shape)</span>
<span class="sd">    (5, 15, 20)</span>
<span class="sd">    &gt;&gt;&gt; np.all(stack1[:, indices[0][0] : indices[0][1], indices[1][0] : indices[1][1]] == first_patch_without_padding)</span>
<span class="sd">    True</span>

<span class="sd">    Note that the patch has no padding at the edges.</span>
<span class="sd">    When looking at the second patch we see that it is padded on both side</span>
<span class="sd">    in the second dimension but still only on one side of the first dimension.</span>

<span class="sd">    &gt;&gt;&gt; second_patch, indices, patch_indices = next(generator)</span>
<span class="sd">    &gt;&gt;&gt; print(second_patch.shape)</span>
<span class="sd">    (5, 18, 26)</span>
<span class="sd">    &gt;&gt;&gt; print(patch_indices)</span>
<span class="sd">    [[0, 15], [3, 23]]</span>
<span class="sd">    &gt;&gt;&gt; print(indices)</span>
<span class="sd">    [[0, 15], [20, 40]]</span>
<span class="sd">    &gt;&gt;&gt; second_patch_without_padding = second_patch[:, patch_indices[0][0] : patch_indices[0][1], patch_indices[1][0] : patch_indices[1][1]]</span>
<span class="sd">    &gt;&gt;&gt; print(second_patch_without_padding.shape)</span>
<span class="sd">    (5, 15, 20)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">load_img</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">memmap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">n_patches_0</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">patch_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">n_patches_1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">patch_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_patches_0</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_patches_1</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="n">patch_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
                <span class="p">[</span><span class="n">patch_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">j</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
            <span class="p">]</span>
            <span class="n">start_dim_0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">start_dim_1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">stop_dim_0</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">stop_dim_1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="n">start_dim_0</span><span class="p">:</span><span class="n">stop_dim_0</span><span class="p">,</span>
                          <span class="n">start_dim_1</span><span class="p">:</span><span class="n">stop_dim_1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">stack</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">return_indices</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">patch</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offset_dim_0</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_dim_0</span>
                <span class="n">offset_dim_1</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_dim_1</span>
                <span class="n">patch_indices</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">[</span><span class="n">offset_dim_0</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset_dim_0</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">offset_dim_1</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset_dim_1</span><span class="p">],</span>
                <span class="p">]</span>
                <span class="k">yield</span> <span class="n">patch</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">patch_indices</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">load_img</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>


<div class="viewcode-block" id="load_raw"><a class="viewcode-back" href="../../load_save.html#utils2p.load_raw">[docs]</a><span class="k">def</span> <span class="nf">load_raw</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function loads a raw image generated by ThorImage as a numpy array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : string</span>
<span class="sd">        Path to raw file.</span>
<span class="sd">    metadata : ElementTree root</span>
<span class="sd">        Can be obtained with :func:`get_metadata`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stacks : tuple of numpy arrays</span>
<span class="sd">        Number of numpy arrays depends on the number of channels recoded during</span>
<span class="sd">        the experiment. Has the following dimensions:</span>
<span class="sd">        TZYX or TYX for planar images.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; metadata = utils2p.Metadata(&#39;data/mouse_kidney_raw/2p/Untitled_001/Experiment.xml&#39;)</span>
<span class="sd">    &gt;&gt;&gt; stack1, stack2 = utils2p.load_raw(&#39;data/mouse_kidney_raw/2p/Untitled_001/Image_0001_0001.raw&#39;,metadata)</span>
<span class="sd">    &gt;&gt;&gt; type(stack1), type(stack2)</span>
<span class="sd">    (&lt;class &#39;numpy.ndarray&#39;&gt;, &lt;class &#39;numpy.ndarray&#39;&gt;)</span>
<span class="sd">    &gt;&gt;&gt; utils2p.save_img(&#39;stack1.tif&#39;,stack1)</span>
<span class="sd">    &gt;&gt;&gt; utils2p.save_img(&#39;stack2.tif&#39;,stack2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expandvars</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="n">n_time_points</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_n_time_points</span><span class="p">()</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_num_x_pixels</span><span class="p">()</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_num_y_pixels</span><span class="p">()</span>
    <span class="n">n_channels</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_n_channels</span><span class="p">()</span>
    <span class="n">byte_size</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_size</span>

    <span class="k">assert</span> <span class="ow">not</span> <span class="n">byte_size</span> <span class="o">%</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;File does not have an integer byte length.&quot;</span>
    <span class="n">byte_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">byte_size</span><span class="p">)</span>

    <span class="n">n_z</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">byte_size</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">width</span> <span class="o">/</span> <span class="n">height</span> <span class="o">/</span> <span class="n">n_time_points</span> <span class="o">/</span> <span class="n">n_channels</span>
    <span class="p">)</span>  <span class="c1"># divide by two because the values are of type short (16bit = 2byte)</span>

    <span class="k">assert</span> <span class="p">(</span>
        <span class="ow">not</span> <span class="n">n_z</span> <span class="o">%</span>
        <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;Size given in metadata does not match the size of the raw file.&quot;</span>
    <span class="n">n_z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_z</span><span class="p">)</span>

    <span class="c1"># number of z slices from meta data can be different</span>
    <span class="c1"># because of flyback frames</span>
    <span class="n">meta_n_z</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_n_z</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">n_z</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">stacks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">n_time_points</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint16&quot;</span><span class="p">)</span>
        <span class="n">image_size</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
        <span class="c1"># number of values stored for a given time point</span>
        <span class="c1"># (this includes images for all channels)</span>
        <span class="n">t_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="n">n_channels</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time_points</span><span class="p">):</span>
                <span class="c1"># print(&#39;{}/{}&#39;.format(t,n_time_points))</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>
                <span class="n">a</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t_size</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_channels</span><span class="p">):</span>
                    <span class="n">stacks</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">c</span> <span class="o">*</span> <span class="n">image_size</span><span class="p">:(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
                                                    <span class="n">image_size</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                                                        <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">n_z</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">stacks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">n_time_points</span><span class="p">,</span> <span class="n">meta_n_z</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint16&quot;</span><span class="p">)</span>
        <span class="n">image_size</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
        <span class="n">t_size</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="n">n_z</span> <span class="o">*</span> <span class="n">n_channels</span>
        <span class="p">)</span>  <span class="c1"># number of values stored for a given time point (this includes images for all channels)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time_points</span><span class="p">):</span>
                <span class="c1"># print(&#39;{}/{}&#39;.format(t,n_time_points))</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>
                <span class="n">a</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t_size</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">image_size</span>
                     <span class="p">))</span>  <span class="c1"># each row is an image alternating between channels</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_channels</span><span class="p">):</span>
                    <span class="n">stacks</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">::</span><span class="n">n_channels</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">n_z</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">))[:</span><span class="n">meta_n_z</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="n">area_mode</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_area_mode</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">area_mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;kymograph&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">meta_n_z</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">concatenated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">stack</span> <span class="ow">in</span> <span class="n">stacks</span><span class="p">:</span>
            <span class="n">concatenated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">concatenate_z</span><span class="p">(</span><span class="n">stack</span><span class="p">))</span>
        <span class="n">stacks</span> <span class="o">=</span> <span class="n">concatenated</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stacks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">stacks</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">stacks</span><span class="p">))</span></div>


<div class="viewcode-block" id="load_z_stack"><a class="viewcode-back" href="../../load_save.html#utils2p.load_z_stack">[docs]</a><span class="k">def</span> <span class="nf">load_z_stack</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads tif files as saved when capturing a z-stack into a 3D numpy array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : string</span>
<span class="sd">        Path to directory of the z-stack.</span>
<span class="sd">    metadata : ElementTree root</span>
<span class="sd">        Can be obtained with :func:`get_metadata`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stacks : tuple of numpy arrays</span>
<span class="sd">        Z-stacks for Channel A (green) and Channel B (red).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; metadata = utils2p.Metadata(&quot;data/mouse_kidney_z_stack/Experiment.xml&quot;)</span>
<span class="sd">    &gt;&gt;&gt; z_stack_A, z_stack_B = utils2p.load_z_stack(&quot;data/mouse_kidney_z_stack/&quot;, metadata)</span>
<span class="sd">    &gt;&gt;&gt; type(z_stack_A), type(z_stack_B)</span>
<span class="sd">    (&lt;class &#39;numpy.ndarray&#39;&gt;, &lt;class &#39;numpy.ndarray&#39;&gt;)</span>
<span class="sd">    &gt;&gt;&gt; z_stack_A.shape, z_stack_B.shape</span>
<span class="sd">    ((3, 128, 128), (3, 128, 128))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expandvars</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="n">channels</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_channels</span><span class="p">()</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;*.tif&quot;</span><span class="p">))</span>
    <span class="n">stacks</span> <span class="o">=</span> <span class="n">load_img</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">stacks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">stacks</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">stacks</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]])</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">stacks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">stacks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]])</span></div>


<div class="viewcode-block" id="concatenate_z"><a class="viewcode-back" href="../../misc_main.html#utils2p.concatenate_z">[docs]</a><span class="k">def</span> <span class="nf">concatenate_z</span><span class="p">(</span><span class="n">stack</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenate in z direction for area mode &#39;line&#39; or &#39;kymograph&#39;,</span>
<span class="sd">    e.g. coronal section. This is necessary because z steps are</span>
<span class="sd">    otherwise treated as additional temporal frame, i.e. in Fiji</span>
<span class="sd">    the frames jump up and down between z positions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stack : 4D or 6D numpy array</span>
<span class="sd">        Stack to be z concatenated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stack : 3D or 5D numpy array</span>
<span class="sd">        Concatenated stack.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; stack = np.zeros((100, 2, 64, 128))</span>
<span class="sd">    &gt;&gt;&gt; concatenated = utils2p.concatenate_z(stack)</span>
<span class="sd">    &gt;&gt;&gt; concatenated.shape</span>
<span class="sd">    (100, 128, 128)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">3</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>


<div class="viewcode-block" id="save_img"><a class="viewcode-back" href="../../load_save.html#utils2p.save_img">[docs]</a><span class="k">def</span> <span class="nf">save_img</span><span class="p">(</span><span class="n">path</span><span class="p">,</span>
             <span class="n">img</span><span class="p">,</span>
             <span class="n">imagej</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">color</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">full_dynamic_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves an image that is given as a numpy array to file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : string</span>
<span class="sd">        Path where the file is saved.</span>
<span class="sd">    img : numpy array</span>
<span class="sd">        Image or stack. For stacks, the first dimension is the stack index.</span>
<span class="sd">        For color images, the last dimension are the RGB channels.</span>
<span class="sd">    imagej : boolean</span>
<span class="sd">        Save imagej compatible stacks and hyperstacks.</span>
<span class="sd">    color : boolean, default = False</span>
<span class="sd">        Determines if image is RGB or gray scale.</span>
<span class="sd">        Will be converted to uint8.</span>
<span class="sd">    full_dynamic_range : boolean, default = True</span>
<span class="sd">        When an image is converted to uint8 for saving a color image the</span>
<span class="sd">        max value of the output image is the max of uint8,</span>
<span class="sd">        i.e. the image uses the full dynamic range available.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">255</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expandvars</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
            <span class="n">old_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">full_dynamic_range</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                    <span class="n">old_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
                    <span class="n">old_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;img must be integer or float type not </span><span class="si">{</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">new_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span> <span class="o">/</span> <span class="n">old_max</span> <span class="o">*</span> <span class="n">new_max</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">imagej</span> <span class="ow">and</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">imagej</span> <span class="ow">and</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">imagej</span> <span class="ow">and</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">imagej</span> <span class="ow">and</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tifffile</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">imagej</span><span class="o">=</span><span class="n">imagej</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO add meta data like metadata={&#39;xresolution&#39;:&#39;4.25&#39;,&#39;yresolution&#39;:&#39;0.0976&#39;,&#39;PixelAspectRatio&#39;:&#39;43.57&#39;}</span>
        <span class="c1"># tifffile.imsave(path, img, imagej=imagej, metadata={})</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Saving of metadata is not yet implemented&quot;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_find_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">file_type</span><span class="p">,</span> <span class="n">most_recent</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function finds a unique file with a given name in</span>
<span class="sd">    in the directory.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    directory : str</span>
<span class="sd">        Directory in which to search.</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the file.</span>
<span class="sd">    most_recent : bool</span>
<span class="sd">        If True, the file with the most recent change time</span>
<span class="sd">        is returned and no exception is raised if multiple</span>
<span class="sd">        files are present.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    path : str</span>
<span class="sd">        Path to file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">file_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">most_recent</span><span class="p">:</span>
            <span class="n">change_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mtime</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">file_names</span><span class="p">]</span>
            <span class="n">file_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">file_names</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">change_times</span><span class="p">)],</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Could not identify </span><span class="si">{</span><span class="n">file_type</span><span class="si">}</span><span class="s2"> file unambiguously. &quot;</span> <span class="o">+</span>
                <span class="sa">f</span><span class="s2">&quot;Discovered </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">file_names</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">file_type</span><span class="si">}</span><span class="s2"> files in </span><span class="si">{</span><span class="n">directory</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No </span><span class="si">{</span><span class="n">file_type</span><span class="si">}</span><span class="s2"> file found in </span><span class="si">{</span><span class="n">directory</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">file_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<div class="viewcode-block" id="find_metadata_file"><a class="viewcode-back" href="../../file_discovery.html#utils2p.find_metadata_file">[docs]</a><span class="k">def</span> <span class="nf">find_metadata_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">most_recent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function finds the path to the metadata file</span>
<span class="sd">    &quot;Experiment.xml&quot; created by ThorImage and returns it.</span>
<span class="sd">    If multiple files with this name are found, it throws</span>
<span class="sd">    an exception unless `most_recent` is `True`, in which case</span>
<span class="sd">    the file with the most recent change time is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    directory : str</span>
<span class="sd">        Directory in which to search.</span>
<span class="sd">    most_recent : bool</span>
<span class="sd">        If True, the file with the most recent change time</span>
<span class="sd">        is returned and no exception is raised if multiple</span>
<span class="sd">        files are present.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    path : str</span>
<span class="sd">        Path to metadata file.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; utils2p.find_metadata_file(&quot;data/mouse_kidney_z_stack&quot;)</span>
<span class="sd">    &#39;data/mouse_kidney_z_stack/Experiment.xml&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_find_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span>
                      <span class="s2">&quot;Experiment.xml&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
                      <span class="n">most_recent</span><span class="o">=</span><span class="n">most_recent</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_seven_camera_metadata_file"><a class="viewcode-back" href="../../file_discovery.html#utils2p.find_seven_camera_metadata_file">[docs]</a><span class="k">def</span> <span class="nf">find_seven_camera_metadata_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">most_recent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function finds the path to the metadata file</span>
<span class="sd">    &quot;capture_metadata.json&quot; created by seven camera</span>
<span class="sd">    setup and returns it.</span>
<span class="sd">    If multiple files with this name are found, it throws</span>
<span class="sd">    an exception unless `most_recent` is `True`, in which case</span>
<span class="sd">    the file with the most recent change time is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    directory : str</span>
<span class="sd">        Directory in which to search.</span>
<span class="sd">    most_recent : bool</span>
<span class="sd">        If True, the file with the most recent change time</span>
<span class="sd">        is returned and no exception is raised if multiple</span>
<span class="sd">        files are present.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    path : str</span>
<span class="sd">        Path to capture metadata file.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; utils2p.find_seven_camera_metadata_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &#39;data/mouse_kidney_raw/behData/images/capture_metadata.json&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_find_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span>
                      <span class="s2">&quot;capture_metadata.json&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;seven camera capture metadata&quot;</span><span class="p">,</span>
                      <span class="n">most_recent</span><span class="o">=</span><span class="n">most_recent</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_sync_file"><a class="viewcode-back" href="../../file_discovery.html#utils2p.find_sync_file">[docs]</a><span class="k">def</span> <span class="nf">find_sync_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">most_recent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function finds the path to the sync file</span>
<span class="sd">    &quot;Episode001.h5&quot; created by ThorSync and returns it.</span>
<span class="sd">    If multiple files with this name are found, it throws</span>
<span class="sd">    an exception unless `most_recent` is `True`, in which case</span>
<span class="sd">    the file with the most recent change time is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    directory : str</span>
<span class="sd">        Directory in which to search.</span>
<span class="sd">    most_recent : bool</span>
<span class="sd">        If True, the file with the most recent change time</span>
<span class="sd">        is returned and no exception is raised if multiple</span>
<span class="sd">        files are present.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    path : str</span>
<span class="sd">        Path to sync file.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; utils2p.find_sync_file(&quot;data/mouse_kidney_z_stack&quot;)</span>
<span class="sd">    &#39;data/mouse_kidney_z_stack/Episode001.h5&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_find_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span>
                      <span class="s2">&quot;Episode001.h5&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;synchronization&quot;</span><span class="p">,</span>
                      <span class="n">most_recent</span><span class="o">=</span><span class="n">most_recent</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_optical_flow_file"><a class="viewcode-back" href="../../file_discovery.html#utils2p.find_optical_flow_file">[docs]</a><span class="k">def</span> <span class="nf">find_optical_flow_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">most_recent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function finds the path to the optical flow file</span>
<span class="sd">    &quot;OptFlow.txt&quot; created by seven camera software and returns it.</span>
<span class="sd">    If multiple files with this name are found, it throws</span>
<span class="sd">    an exception unless `most_recent` is `True`,in which case</span>
<span class="sd">    the file with the most recent change time is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    directory : str</span>
<span class="sd">        Directory in which to search.</span>
<span class="sd">    most_recent : bool</span>
<span class="sd">        If True, the file with the most recent change time</span>
<span class="sd">        is returned and no exception is raised if multiple</span>
<span class="sd">        files are present.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    path : str</span>
<span class="sd">        Path to optical flow file.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; utils2p.find_optical_flow_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &#39;data/mouse_kidney_raw/behData/OptFlowData/OptFlow.txt&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_find_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span>
                      <span class="s2">&quot;OptFlow.txt&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;optical flow&quot;</span><span class="p">,</span>
                      <span class="n">most_recent</span><span class="o">=</span><span class="n">most_recent</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_raw_file"><a class="viewcode-back" href="../../file_discovery.html#utils2p.find_raw_file">[docs]</a><span class="k">def</span> <span class="nf">find_raw_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">most_recent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function finds the path to the raw file</span>
<span class="sd">    &quot;Image_0001_0001.raw&quot; created by ThorImage and returns it.</span>
<span class="sd">    If multiple files with this name are found, it throws</span>
<span class="sd">    an exception unless `most_recent` is `True`, in which case</span>
<span class="sd">    the file with the most recent change time is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    directory : str</span>
<span class="sd">        Directory in which to search.</span>
<span class="sd">    most_recent : bool</span>
<span class="sd">        If True, the file with the most recent change time</span>
<span class="sd">        is returned and no exception is raised if multiple</span>
<span class="sd">        files are present.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    path : str</span>
<span class="sd">        Path to raw file.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; utils2p.find_raw_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &#39;data/mouse_kidney_raw/2p/Untitled_001/Image_0001_0001.raw&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_find_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span>
                      <span class="s2">&quot;Image_0001_0001.raw&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;raw&quot;</span><span class="p">,</span>
                      <span class="n">most_recent</span><span class="o">=</span><span class="n">most_recent</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_sync_metadata_file"><a class="viewcode-back" href="../../file_discovery.html#utils2p.find_sync_metadata_file">[docs]</a><span class="k">def</span> <span class="nf">find_sync_metadata_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">most_recent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function finds the path to the synchronization</span>
<span class="sd">    metadata file &quot;ThorRealTimeDataSettings.xml&quot; created</span>
<span class="sd">    by ThorSync. If multiple files with this name are found,</span>
<span class="sd">    it throws an exception unless `most_recent` is `True`,</span>
<span class="sd">    in which case the file with the most recent change time</span>
<span class="sd">    is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    directory : str</span>
<span class="sd">        Directory in which to search.</span>
<span class="sd">    most_recent : bool</span>
<span class="sd">        If True, the file with the most recent change time</span>
<span class="sd">        is returned and no exception is raised if multiple</span>
<span class="sd">        files are present.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    path : str</span>
<span class="sd">        Path to synchronization metadata file.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; utils2p.find_sync_metadata_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &#39;data/mouse_kidney_raw/2p/Sync-025/ThorRealTimeDataSettings.xml&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_find_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span>
                      <span class="s2">&quot;ThorRealTimeDataSettings.xml&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;synchronization metadata&quot;</span><span class="p">,</span>
                      <span class="n">most_recent</span><span class="o">=</span><span class="n">most_recent</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_fictrac_file"><a class="viewcode-back" href="../../file_discovery.html#utils2p.find_fictrac_file">[docs]</a><span class="k">def</span> <span class="nf">find_fictrac_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">camera</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">most_recent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function finds the path to the output file of</span>
<span class="sd">    fictrac of the form `camera_{cam}*.dat`, where</span>
<span class="sd">    `{cam}` is the values specified in the `camera`</span>
<span class="sd">    argument. If multiple files with this name are found,</span>
<span class="sd">    it throws an exception unless `most_recent` is `True`,</span>
<span class="sd">    in which case the file with the most recent change time</span>
<span class="sd">    is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    directory : str</span>
<span class="sd">        Directory in which to search.</span>
<span class="sd">    camera : int</span>
<span class="sd">        The camera used for fictrac.</span>
<span class="sd">    most_recent : bool</span>
<span class="sd">        If True, the file with the most recent change time</span>
<span class="sd">        is returned and no exception is raised if multiple</span>
<span class="sd">        files are present.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    path : str</span>
<span class="sd">        Path to fictrac output file.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; utils2p.find_fictrac_file(&quot;data&quot;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">     ...</span>
<span class="sd">    RuntimeError: Could not identify fictrac output file unambiguously. Discovered 2 fictrac output files in data.</span>
<span class="sd">    &gt;&gt;&gt; utils2p.find_fictrac_file(&quot;data&quot;, most_recent=True)</span>
<span class="sd">    &#39;data/camera_3-20210803_103010.dat&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_find_file</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span>
                      <span class="sa">f</span><span class="s2">&quot;camera_</span><span class="si">{</span><span class="n">camera</span><span class="si">}</span><span class="s2">*.dat&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;fictrac output&quot;</span><span class="p">,</span>
                      <span class="n">most_recent</span><span class="o">=</span><span class="n">most_recent</span><span class="p">)</span></div>


<div class="viewcode-block" id="load_optical_flow"><a class="viewcode-back" href="../../load_save.html#utils2p.load_optical_flow">[docs]</a><span class="k">def</span> <span class="nf">load_optical_flow</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                      <span class="n">gain_0_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="n">gain_0_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="n">gain_1_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="n">gain_1_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="n">smoothing_kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function loads the optical flow data from</span>
<span class="sd">    the file specified in path. By default it is</span>
<span class="sd">    directly converted into ball rotation. Gain values</span>
<span class="sd">    have to be determined with the calibration of the</span>
<span class="sd">    optical flow sensors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str</span>
<span class="sd">        Path to file holding the optical flow data.</span>
<span class="sd">    gain_0_x: float</span>
<span class="sd">        Gain for the x direction of sensor 0.</span>
<span class="sd">    gain_0_y: float</span>
<span class="sd">        Gain for the y direction of sensor 0.</span>
<span class="sd">    gain_1_x: float</span>
<span class="sd">        Gain for the x direction of sensor 1.</span>
<span class="sd">    gain_1_y: float</span>
<span class="sd">        Gain for the y direction of sensor 1.</span>
<span class="sd">    smoothing_kernel: numpy array, optional</span>
<span class="sd">        Default is None, in which case the sensor signals</span>
<span class="sd">        are not smoothed. The signal is convolved with this</span>
<span class="sd">        kernel. A reasonable choice seems to be a moving average</span>
<span class="sd">        filter of length 300: np.ones(300) / 300.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : dictionary</span>
<span class="sd">        A dictionary with keys: &#39;sensor0&#39;, &#39;sensor1&#39;,</span>
<span class="sd">        &#39;time_stamps&#39;, &#39;vel_pitch&#39;, &#39;vel_yaw&#39;, &#39;vel_roll&#39;.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; gain_0_x = round(1 / 1.45, 2)</span>
<span class="sd">    &gt;&gt;&gt; gain_0_y = round(1 / 1.41, 2)</span>
<span class="sd">    &gt;&gt;&gt; gain_1_x = round(1 / 1.40, 2)</span>
<span class="sd">    &gt;&gt;&gt; gain_1_y = round(1 / 1.36, 2)</span>

<span class="sd">    &gt;&gt;&gt; optical_flow_file = utils2p.find_optical_flow_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &gt;&gt;&gt; optical_flow = utils2p.load_optical_flow(optical_flow_file, gain_0_x, gain_0_y, gain_1_x, gain_1_y)</span>
<span class="sd">    &gt;&gt;&gt; type(optical_flow)</span>
<span class="sd">    &lt;class &#39;dict&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; optical_flow.keys()</span>
<span class="sd">    dict_keys([&#39;sensor0&#39;, &#39;sensor1&#39;, &#39;time_stamps&#39;, &#39;vel_pitch&#39;, &#39;vel_yaw&#39;, &#39;vel_roll&#39;])</span>

<span class="sd">    &gt;&gt;&gt; type(optical_flow[&quot;time_stamps&quot;])</span>
<span class="sd">    &lt;class &#39;numpy.ndarray&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; optical_flow[&quot;time_stamps&quot;].shape</span>
<span class="sd">    (1408,)</span>

<span class="sd">    &gt;&gt;&gt; type(optical_flow[&quot;vel_pitch&quot;])</span>
<span class="sd">    &lt;class &#39;numpy.ndarray&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; optical_flow[&quot;vel_pitch&quot;].shape</span>
<span class="sd">    (1408,)</span>

<span class="sd">    &gt;&gt;&gt; type(optical_flow[&quot;vel_yaw&quot;])</span>
<span class="sd">    &lt;class &#39;numpy.ndarray&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; optical_flow[&quot;vel_yaw&quot;].shape</span>
<span class="sd">    (1408,)</span>

<span class="sd">    &gt;&gt;&gt; type(optical_flow[&quot;vel_roll&quot;])</span>
<span class="sd">    &lt;class &#39;numpy.ndarray&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; optical_flow[&quot;vel_roll&quot;].shape</span>
<span class="sd">    (1408,)</span>

<span class="sd">    &gt;&gt;&gt; type(optical_flow[&quot;sensor0&quot;])</span>
<span class="sd">    &lt;class &#39;dict&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; optical_flow[&quot;sensor0&quot;].keys()</span>
<span class="sd">    dict_keys([&#39;x&#39;, &#39;y&#39;, &#39;gain_x&#39;, &#39;gain_y&#39;])</span>

<span class="sd">    &gt;&gt;&gt; optical_flow = utils2p.load_optical_flow(optical_flow_file, gain_0_x, gain_0_y, gain_1_x, gain_1_y, smoothing_kernel=np.ones(300) / 300)</span>
<span class="sd">    &gt;&gt;&gt; optical_flow[&quot;vel_pitch&quot;].shape</span>
<span class="sd">    (1408,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">raw_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">smoothing_kernel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">smoothing_kernel</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;smoothing_kernel of shape </span><span class="si">{</span><span class="n">smoothing_kernel</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> &quot;</span> <span class="o">+</span>
                <span class="sa">f</span><span class="s2">&quot;is longer than optical flow data of shape </span><span class="si">{</span><span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">raw_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">smoothing_kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">raw_data</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;sensor0&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">raw_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">raw_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="s2">&quot;gain_x&quot;</span><span class="p">:</span> <span class="n">gain_0_x</span><span class="p">,</span>
            <span class="s2">&quot;gain_y&quot;</span><span class="p">:</span> <span class="n">gain_0_y</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;sensor1&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">raw_data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">raw_data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span>
            <span class="s2">&quot;gain_x&quot;</span><span class="p">:</span> <span class="n">gain_1_x</span><span class="p">,</span>
            <span class="s2">&quot;gain_y&quot;</span><span class="p">:</span> <span class="n">gain_1_y</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;time_stamps&quot;</span><span class="p">:</span> <span class="n">raw_data</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;vel_pitch&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sensor0&quot;</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sensor0&quot;</span><span class="p">][</span><span class="s2">&quot;gain_y&quot;</span><span class="p">]</span> <span class="o">+</span>
                          <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sensor1&quot;</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">*</span>
                          <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sensor1&quot;</span><span class="p">][</span><span class="s2">&quot;gain_y&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">45</span><span class="p">))</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;vel_yaw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sensor0&quot;</span><span class="p">][</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sensor0&quot;</span><span class="p">][</span><span class="s2">&quot;gain_x&quot;</span><span class="p">]</span> <span class="o">+</span>
                       <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sensor1&quot;</span><span class="p">][</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sensor1&quot;</span><span class="p">][</span><span class="s2">&quot;gain_x&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;vel_roll&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sensor0&quot;</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sensor0&quot;</span><span class="p">][</span><span class="s2">&quot;gain_y&quot;</span><span class="p">]</span> <span class="o">-</span>
                        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sensor1&quot;</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">*</span>
                        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sensor1&quot;</span><span class="p">][</span><span class="s2">&quot;gain_y&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">45</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="load_fictrac"><a class="viewcode-back" href="../../load_save.html#utils2p.load_fictrac">[docs]</a><span class="k">def</span> <span class="nf">load_fictrac</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ball_radius</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This functions loads the fictrac data from file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str</span>
<span class="sd">        Path to fictrac output file (.dat).</span>
<span class="sd">    ball_radius : int</span>
<span class="sd">        Radius of the spherical treadmill.</span>
<span class="sd">    fps : float</span>
<span class="sd">        Number of frames per second.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : dictionary</span>
<span class="sd">        A dictionary with the following keys:</span>
<span class="sd">        Speed, x, y, forward_pos, side_pos, delta_rot_lab_side,</span>
<span class="sd">        delta_rot_lab_forward, delta_rot_lab_turn, integrated_forward_movement,</span>
<span class="sd">        integrated_side_movement, Time</span>
<span class="sd">        All speeds are in mm/s and all positions are in mm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;Frame_counter&quot;</span><span class="p">,</span> <span class="s2">&quot;delta_rot_cam_right&quot;</span><span class="p">,</span> <span class="s2">&quot;delta_rot_cam_down&quot;</span><span class="p">,</span>
        <span class="s2">&quot;delta_rot_cam_forward&quot;</span><span class="p">,</span> <span class="s2">&quot;delta_rot_error&quot;</span><span class="p">,</span> <span class="s2">&quot;delta_rot_lab_side&quot;</span><span class="p">,</span>
        <span class="s2">&quot;delta_rot_lab_forward&quot;</span><span class="p">,</span> <span class="s2">&quot;delta_rot_lab_turn&quot;</span><span class="p">,</span> <span class="s2">&quot;abs_rot_cam_right&quot;</span><span class="p">,</span>
        <span class="s2">&quot;abs_rot_cam_down&quot;</span><span class="p">,</span> <span class="s2">&quot;abs_rot_cam_forward&quot;</span><span class="p">,</span> <span class="s2">&quot;abs_rot_lab_side&quot;</span><span class="p">,</span>
        <span class="s2">&quot;abs_rot_lab_forward&quot;</span><span class="p">,</span> <span class="s2">&quot;abs_rot_lab_turn&quot;</span><span class="p">,</span> <span class="s2">&quot;integrated_lab_x&quot;</span><span class="p">,</span>
        <span class="s2">&quot;integrated_lab_y&quot;</span><span class="p">,</span> <span class="s2">&quot;integrated_lab_heading&quot;</span><span class="p">,</span>
        <span class="s2">&quot;animal_movement_direction_lab&quot;</span><span class="p">,</span> <span class="s2">&quot;animal_movement_speed&quot;</span><span class="p">,</span>
        <span class="s2">&quot;integrated_forward_movement&quot;</span><span class="p">,</span> <span class="s2">&quot;integrated_side_movement&quot;</span><span class="p">,</span> <span class="s2">&quot;timestamp&quot;</span><span class="p">,</span>
        <span class="s2">&quot;seq_counter&quot;</span><span class="p">,</span> <span class="s2">&quot;delta_time&quot;</span><span class="p">,</span> <span class="s2">&quot;alt_time&quot;</span>
    <span class="p">]</span>

    <span class="n">dat_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col_names</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">dat_table</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;Speed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;animal_movement_speed&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ball_radius</span> <span class="o">*</span> <span class="n">fps</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;integrated_lab_x&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ball_radius</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;integrated_lab_y&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ball_radius</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;forward_pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;integrated_forward_movement&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ball_radius</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;side_pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;integrated_side_movement&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ball_radius</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_rot_lab_side&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_rot_lab_side&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ball_radius</span> <span class="o">*</span> <span class="n">fps</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_rot_lab_forward&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span>
        <span class="s2">&quot;delta_rot_lab_forward&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ball_radius</span> <span class="o">*</span> <span class="n">fps</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_rot_lab_turn&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span>
        <span class="s2">&quot;delta_rot_lab_turn&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">360</span> <span class="o">*</span> <span class="n">fps</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;integrated_forward_movement&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span>
        <span class="s2">&quot;integrated_forward_movement&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ball_radius</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;integrated_side_movement&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span>
        <span class="s2">&quot;integrated_side_movement&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ball_radius</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;Time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;Frame_counter&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">fps</span>

    <span class="k">return</span> <span class="n">data</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">utils2p</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../main.html">Core functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../synchronization.html">Synchronization functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Florian Aymanns.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>