
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>utils2p.synchronization &#8212; utils2p  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" href="../../_static/css/functions.css" type="text/css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for utils2p.synchronization</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Synchronization module</span>
<span class="sd">======================</span>

<span class="sd">This module provides functions to process the synchronization data</span>
<span class="sd">acquired with Thor Sync during imaging.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>

<span class="kn">import</span> <span class="nn">utils2p.main</span> <span class="k">as</span> <span class="nn">main</span>


<span class="k">class</span> <span class="nc">SynchronizationError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The input data is not consistent with synchronization assumption.&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">get_lines_from_h5_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">line_names</span><span class="p">):</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;get_lines_from_h5_file is deprecated use get_lines_from_sync_file instead&quot;</span><span class="p">,</span>
        <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">get_lines_from_sync_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">line_names</span><span class="p">)</span>


<div class="viewcode-block" id="get_lines_from_sync_file"><a class="viewcode-back" href="../../loading_preprocessing.html#utils2p.synchronization.get_lines_from_sync_file">[docs]</a><span class="k">def</span> <span class="nf">get_lines_from_sync_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">line_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function returns the values of the requested lines save in</span>
<span class="sd">    an h5 generated by ThorSync.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file_path : string</span>
<span class="sd">        Path to h5 file.</span>
<span class="sd">    line_names : list of strings</span>
<span class="sd">        List of the ThorSync line names to be returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lines : tuple</span>
<span class="sd">        Line arrays in the same order as given in line_names.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; h5_file = utils2p.find_sync_file(&quot;data/mouse_kidney_z_stack&quot;)</span>
<span class="sd">    &gt;&gt;&gt; line_names = [&quot;Frame Counter&quot;, &quot;Capture On&quot;]</span>
<span class="sd">    &gt;&gt;&gt; frame_counter, capture_on = utils2p.synchronization.get_lines_from_h5_file(h5_file, line_names)</span>
<span class="sd">    &gt;&gt;&gt; type(frame_counter)</span>
<span class="sd">    &lt;class &#39;numpy.ndarray&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; frame_counter.shape</span>
<span class="sd">    (54000,)</span>
<span class="sd">    &gt;&gt;&gt; type(capture_on)</span>
<span class="sd">    &lt;class &#39;numpy.ndarray&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; capture_on.shape</span>
<span class="sd">    (54000,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">line_names</span><span class="p">:</span>
            <span class="n">lines_with_this_name</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">line_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;DI&quot;</span><span class="p">,</span> <span class="s2">&quot;CI&quot;</span><span class="p">,</span> <span class="s2">&quot;AI&quot;</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lines_with_this_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">line_type</span><span class="p">][</span><span class="n">name</span><span class="p">][:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines_with_this_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lines_with_this_name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines_with_this_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">DI_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;DI&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">CI_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;CI&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">AI_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;AI&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No line named &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; exists. The digital lines are &quot;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">DI_keys</span><span class="si">}</span><span class="s2">, the continuous lines are </span><span class="si">{</span><span class="n">CI_keys</span><span class="si">}</span><span class="s2">, &quot;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s2">&quot;and  the analogue inputs are </span><span class="si">{</span><span class="n">AI_keys</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">DI_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;DI&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">CI_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;CI&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">AI_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;AI&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Multiple lines named &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; exist. &quot;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s2">&quot;The digital lines are </span><span class="si">{</span><span class="n">DI_keys</span><span class="si">}</span><span class="s2">, the continuous lines &quot;</span> <span class="o">+</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;are </span><span class="si">{</span><span class="n">CI_keys</span><span class="si">}</span><span class="s2">, and  the analogue inputs are </span><span class="si">{</span><span class="n">AI_keys</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_times"><a class="viewcode-back" href="../../misc_sync.html#utils2p.synchronization.get_times">[docs]</a><span class="k">def</span> <span class="nf">get_times</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function returns the time point of each tick</span>
<span class="sd">    for a given sequence length and tick frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    length : int</span>
<span class="sd">        Length of sequence.</span>
<span class="sd">    freq : float</span>
<span class="sd">        Frequency in Hz.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    times : array</span>
<span class="sd">        Times in seconds.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.get_times(5, 20)</span>
<span class="sd">    array([0.  , 0.05, 0.1 , 0.15, 0.2 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span> <span class="o">/</span> <span class="n">freq</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">freq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">times</span></div>


<div class="viewcode-block" id="edges"><a class="viewcode-back" href="../../misc_sync.html#utils2p.synchronization.edges">[docs]</a><span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">correct_possible_split_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the indices of edges in a line. An</span>
<span class="sd">    edge is change in value of the line. A size</span>
<span class="sd">    argument can be specified to filter for changes</span>
<span class="sd">    of specific magnitude. By default only rising</span>
<span class="sd">    edges (increases in value) are returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line : numpy array</span>
<span class="sd">        Line signal from h5 file.</span>
<span class="sd">    size : float or tuple</span>
<span class="sd">        Size of the rising edge. If float it is used as minimum.</span>
<span class="sd">        Tuples specify a range. To get falling edges use negative values.</span>
<span class="sd">        Only one boundary can be applied using np.inf as one of the values.</span>
<span class="sd">        All boundaries are excluding the specified value.</span>
<span class="sd">    correct_possible_split_edges : boolean</span>
<span class="sd">        The rise or fall of an edge can in some cases be spread over</span>
<span class="sd">        several ticks. If `True` these &quot;blurry&quot; edges are sharpened</span>
<span class="sd">        with :func:`utils2p.synchronization.correct_split_edges`.</span>
<span class="sd">        Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices : list</span>
<span class="sd">        Indices of the rising edges.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; binary_line = np.array([0, 1, 1, 0, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.edges(binary_line)</span>
<span class="sd">    (array([1, 4]),)</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.edges(binary_line, size=2)</span>
<span class="sd">    (array([], dtype=int64),)</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.edges(binary_line, size=(-np.inf, np.inf))</span>
<span class="sd">    (array([1, 3, 4]),)</span>
<span class="sd">    &gt;&gt;&gt; continuous_line = np.array([0, 0, 3, 3, 3, 5, 5, 8, 8, 10, 10, 10])</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.edges(continuous_line)</span>
<span class="sd">    (array([2, 5, 7, 9]),)</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.edges(continuous_line, size=2)</span>
<span class="sd">    (array([2, 7]),)</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.edges(continuous_line, size=(-np.inf, 3))</span>
<span class="sd">    (array([5, 9]),)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">correct_possible_split_edges</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">correct_split_edges</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">zero_elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
        <span class="n">edges_in_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">valid_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">edges_in_range</span><span class="p">,</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">zero_elements</span><span class="p">))</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid_edges</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">indices</span></div>


<div class="viewcode-block" id="correct_split_edges"><a class="viewcode-back" href="../../misc_sync.html#utils2p.synchronization.correct_split_edges">[docs]</a><span class="k">def</span> <span class="nf">correct_split_edges</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function corrects edges that are spread over multiple ticks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line : numpy array</span>
<span class="sd">        The line for which the edges should be corrected.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    line : numpy array</span>
<span class="sd">        Line with corrected edges.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; line = np.array([0, 0, 0, 1, 2, 3, 3, 3, 2, 1, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.correct_split_edges(line)</span>
<span class="sd">    array([0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rising_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">falling_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">split_rising_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rising_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">split_falling_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">falling_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_rising_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_falling_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">line</span>

    <span class="n">first_halfs_rising</span> <span class="o">=</span> <span class="n">rising_edges</span><span class="p">[</span><span class="n">split_rising_edges</span><span class="p">]</span>
    <span class="n">second_halfs_rising</span> <span class="o">=</span> <span class="n">rising_edges</span><span class="p">[</span><span class="n">split_rising_edges</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">line</span><span class="p">[</span><span class="n">first_halfs_rising</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">second_halfs_rising</span><span class="p">]</span>

    <span class="n">first_halfs_falling</span> <span class="o">=</span> <span class="n">falling_edges</span><span class="p">[</span><span class="n">split_falling_edges</span><span class="p">]</span>
    <span class="n">second_halfs_falling</span> <span class="o">=</span> <span class="n">falling_edges</span><span class="p">[</span><span class="n">split_falling_edges</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">line</span><span class="p">[</span><span class="n">second_halfs_falling</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">first_halfs_falling</span><span class="p">]</span>

    <span class="c1"># Recursive to get edges spread over more than two ticks</span>
    <span class="k">return</span> <span class="n">correct_split_edges</span><span class="p">(</span><span class="n">line</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_start_times"><a class="viewcode-back" href="../../misc_sync.html#utils2p.synchronization.get_start_times">[docs]</a><span class="k">def</span> <span class="nf">get_start_times</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">zero_based_counter</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the start times of a digital signal,</span>
<span class="sd">    i.e. the times of the rising edges.</span>
<span class="sd">    If the line is a zero based counter, such as the processed </span>
<span class="sd">    `frame_counter` or the processed `cam_line`, there is a</span>
<span class="sd">    possibility that the first element in line is already zero.</span>
<span class="sd">    This corresponds to the case where the acquisition of the</span>
<span class="sd">    first frame was triggered before ThorSync started.</span>
<span class="sd">    If `zero_based_counter` is `False` this frame will be</span>
<span class="sd">    dropped, i.e. no time for the frame is returned, since</span>
<span class="sd">    there is no rising edge corresponding to the frame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line : numpy array</span>
<span class="sd">        Line signal from h5 file.</span>
<span class="sd">    times : numpy array</span>
<span class="sd">        Times returned by :func:`utils2p.synchronization.get_times`</span>
<span class="sd">    zero_based_counter : boolean</span>
<span class="sd">        Indicates whether the line is a zero based counter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    time_points : list</span>
<span class="sd">        List of the start times.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; binary_line = np.array([0, 1, 1, 0, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; times = utils2p.synchronization.get_times(len(binary_line), freq=20)</span>
<span class="sd">    &gt;&gt;&gt; times</span>
<span class="sd">    array([0.  , 0.05, 0.1 , 0.15, 0.2 , 0.25])</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.get_start_times(binary_line, times)</span>
<span class="sd">    array([0.05, 0.2 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">edges</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">zero_based_counter</span> <span class="ow">and</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The counter start with value </span><span class="si">{</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">indices_with_first_frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">indices_with_first_frame</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices_with_first_frame</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">time_points</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">time_points</span></div>


<span class="k">def</span> <span class="nf">_capture_metadata</span><span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">dropped_frames</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a dictionary as it is usually saved by the seven</span>
<span class="sd">    camera setup in the &quot;capture_metadata.json&quot; file.</span>
<span class="sd">    It assumes that no frames where dropped.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_frames : list of integers</span>
<span class="sd">        Number of frames for each camera.</span>
<span class="sd">    dropped_frames : list of list of integers</span>
<span class="sd">        Frames that were dropped for each camera.</span>
<span class="sd">        Default is None which means no frames where</span>
<span class="sd">        dropped.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    capture_info : dict</span>
<span class="sd">        Default metadata dictionary for the seven camera</span>
<span class="sd">        system.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dropped_frames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dropped_frames</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n_frames</span><span class="p">))]</span>
    <span class="n">capture_info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Frame Counts&quot;</span><span class="p">:</span> <span class="p">{}}</span>
    <span class="k">for</span> <span class="n">cam_idx</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">n_frames</span><span class="p">):</span>
        <span class="n">frames_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">current_frame</span> <span class="ow">in</span> <span class="n">dropped_frames</span><span class="p">[</span><span class="n">cam_idx</span><span class="p">]:</span>
                <span class="n">current_frame</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">frames_dict</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">current_frame</span>
            <span class="n">current_frame</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">capture_info</span><span class="p">[</span><span class="s2">&quot;Frame Counts&quot;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">cam_idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">frames_dict</span>
    <span class="k">return</span> <span class="n">capture_info</span>


<div class="viewcode-block" id="process_cam_line"><a class="viewcode-back" href="../../loading_preprocessing.html#utils2p.synchronization.process_cam_line">[docs]</a><span class="k">def</span> <span class="nf">process_cam_line</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">seven_camera_metadata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes superfluous signals and uses frame numbers in array.</span>
<span class="sd">    The cam line signal form the h5 file is a binary sequence.</span>
<span class="sd">    Rising edges mark the acquisition of a new frame.</span>
<span class="sd">    The setup keeps producing rising edges after the acquisition of the</span>
<span class="sd">    last frame. These rising edges are ignored.</span>
<span class="sd">    This function converts the binary line to frame numbers using the</span>
<span class="sd">    information stored in the metadata file of the seven camera setup.</span>
<span class="sd">    In the metadata file the keys are the indices of the file names</span>
<span class="sd">    and the values are the grabbed frame numbers. Suppose the 3</span>
<span class="sd">    frame was dropped. Then the entries in the dictionary will</span>
<span class="sd">    be as follows:</span>
<span class="sd">    &quot;2&quot;: 2</span>
<span class="sd">    &quot;3&quot;: 4</span>
<span class="sd">    &quot;4&quot;: 5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line : numpy array</span>
<span class="sd">        Line signal from h5 file.</span>
<span class="sd">    seven_camera_metadata : string</span>
<span class="sd">        Path to the json file saved by our camera software.</span>
<span class="sd">        This file is usually located in the same folder as the frames</span>
<span class="sd">        and is called &#39;capture_metadata.json&#39;. If None, it is assumed</span>
<span class="sd">        that no frames were dropped.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    processed_line : numpy array</span>
<span class="sd">        Array with frame number for each time point.</span>
<span class="sd">        If no frame is available for a given time,</span>
<span class="sd">        the value is -9223372036854775808.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; h5_file = utils2p.find_sync_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &gt;&gt;&gt; seven_camera_metadata = utils2p.find_seven_camera_metadata_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &gt;&gt;&gt; line_names = [&quot;Basler&quot;]</span>
<span class="sd">    &gt;&gt;&gt; (cam_line,) = utils2p.synchronization.get_lines_from_h5_file(h5_file, line_names)</span>
<span class="sd">    &gt;&gt;&gt; set(np.diff(cam_line))</span>
<span class="sd">    {0, 8, 4294967288}</span>
<span class="sd">    &gt;&gt;&gt; processed_cam_line = utils2p.synchronization.process_cam_line(cam_line, seven_camera_metadata)</span>
<span class="sd">    &gt;&gt;&gt; set(np.diff(processed_cam_line))</span>
<span class="sd">    {0, 1, -9223372036854775808, 9223372036854775749}</span>
<span class="sd">    &gt;&gt;&gt; cam_line = np.array([0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.process_cam_line(cam_line, seven_camera_metadata=None)</span>
<span class="sd">    array([-9223372036854775808,                    0,                    0,</span>
<span class="sd">                              0,                    0,                    0,</span>
<span class="sd">                              1,                    1,                    1,</span>
<span class="sd">                              1,                    1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that sequence is binary</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">line</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid line argument. Sequence is not binary.&quot;</span><span class="p">)</span>

    <span class="c1"># Find indices of the start of each frame acquisition</span>
    <span class="n">rising_edges</span> <span class="o">=</span> <span class="n">edges</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Load capture metadata or generate default</span>
    <span class="k">if</span> <span class="n">seven_camera_metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">seven_camera_metadata</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">capture_info</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">capture_info</span> <span class="o">=</span> <span class="n">_capture_metadata</span><span class="p">([</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">rising_edges</span><span class="p">),</span>
        <span class="p">])</span>

    <span class="c1"># Find the number of frames for each camera</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cam_idx</span> <span class="ow">in</span> <span class="n">capture_info</span><span class="p">[</span><span class="s2">&quot;Frame Counts&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">max_in_json</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">capture_info</span><span class="p">[</span><span class="s2">&quot;Frame Counts&quot;</span><span class="p">][</span><span class="n">cam_idx</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">n_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_in_json</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Ensure all cameras acquired the same number of frames</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">n_frames</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">SynchronizationError</span><span class="p">(</span>
            <span class="s2">&quot;The frames across cameras are not synchronized.&quot;</span><span class="p">)</span>

    <span class="c1"># Last rising edge that corresponds to a frame</span>
    <span class="n">last_tick</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n_frames</span><span class="p">)</span>

    <span class="c1"># check that there is a rising edge for every frame</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rising_edges</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">last_tick</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The provided cam line and metadata are inconsistent. &quot;</span> <span class="o">+</span>
            <span class="s2">&quot;cam line has less frame acquisitions than metadata.&quot;</span><span class="p">)</span>

    <span class="c1"># Ensure correct handling if no rising edges are present after last frame</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rising_edges</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">last_tick</span><span class="p">):</span>
        <span class="n">average_frame_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rising_edges</span><span class="p">)))</span>
        <span class="n">last_rising_edge</span> <span class="o">=</span> <span class="n">rising_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">additional_edge</span> <span class="o">=</span> <span class="n">last_rising_edge</span> <span class="o">+</span> <span class="n">average_frame_length</span>
        <span class="k">if</span> <span class="n">additional_edge</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">additional_edge</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">rising_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rising_edges</span><span class="p">)</span>
        <span class="n">rising_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">additional_edge</span><span class="p">)</span>
        <span class="n">rising_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rising_edges</span><span class="p">)</span>

    <span class="n">processed_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">current_frame</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">first_camera_used</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">capture_info</span><span class="p">[</span><span class="s2">&quot;Frame Counts&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">rising_edges</span><span class="p">[:</span><span class="n">last_tick</span><span class="p">],</span> <span class="n">rising_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">last_tick</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])):</span>
        <span class="k">if</span> <span class="n">capture_info</span><span class="p">[</span><span class="s2">&quot;Frame Counts&quot;</span><span class="p">][</span><span class="n">first_camera_used</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">current_frame</span> <span class="o">+</span>
                                                               <span class="mi">1</span><span class="p">)]</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">current_frame</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">processed_line</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_frame</span>
    <span class="k">return</span> <span class="n">processed_line</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_frame_counter"><a class="viewcode-back" href="../../loading_preprocessing.html#utils2p.synchronization.process_frame_counter">[docs]</a><span class="k">def</span> <span class="nf">process_frame_counter</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">steps_per_frame</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the frame counter line to an array with frame numbers for each</span>
<span class="sd">    time point.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line : numpy array</span>
<span class="sd">        Line signal from h5 file.</span>
<span class="sd">    metadata : :class:`utils2p.Metadata`</span>
<span class="sd">        :class:`utils2p.Metadata` object that holding the 2p imaging</span>
<span class="sd">        metadata for the experiment. Optional. If metadata is not</span>
<span class="sd">        given steps_per_frame has to be set.</span>
<span class="sd">    steps_per_frame : int</span>
<span class="sd">        Number of steps the frame counter takes per frame.</span>
<span class="sd">        This includes fly back frames and averaging, i.e. if you</span>
<span class="sd">        acquire one frame and flyback frames is set to 3 this number</span>
<span class="sd">        should be 4.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    processed_frame_counter : numpy array</span>
<span class="sd">        Array with frame number for each time point.</span>
<span class="sd">        If no frame was recorded at a time point, </span>
<span class="sd">        the value is -9223372036854775808.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; h5_file = utils2p.find_sync_file(&quot;data/mouse_kidney_z_stack&quot;)</span>
<span class="sd">    &gt;&gt;&gt; line_names = [&quot;Frame Counter&quot;,]</span>
<span class="sd">    &gt;&gt;&gt; (frame_counter,) = utils2p.synchronization.get_lines_from_h5_file(h5_file, line_names)</span>
<span class="sd">    &gt;&gt;&gt; set(frame_counter)</span>
<span class="sd">    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}</span>
<span class="sd">    &gt;&gt;&gt; metadata_file = utils2p.find_metadata_file(&quot;data/mouse_kidney_z_stack&quot;)</span>
<span class="sd">    &gt;&gt;&gt; metadata = utils2p.Metadata(metadata_file)</span>
<span class="sd">    &gt;&gt;&gt; processed_frame_counter = utils2p.synchronization.process_frame_counter(frame_counter, metadata)</span>
<span class="sd">    &gt;&gt;&gt; set(processed_frame_counter)</span>
<span class="sd">    {0, -9223372036854775808}</span>
<span class="sd">    &gt;&gt;&gt; steps_per_frame = metadata.get_n_z() * metadata.get_n_averaging()</span>
<span class="sd">    &gt;&gt;&gt; steps_per_frame</span>
<span class="sd">    30</span>
<span class="sd">    &gt;&gt;&gt; processed_frame_counter = utils2p.synchronization.process_frame_counter(frame_counter, steps_per_frame=steps_per_frame)</span>
<span class="sd">    &gt;&gt;&gt; set(processed_frame_counter)</span>
<span class="sd">    {0, -9223372036854775808}</span>

<span class="sd">    By default the function treat volumes as frames.</span>
<span class="sd">    If you want to treat every slice of the volume as a separate frame,</span>
<span class="sd">    you can do so by `steps_per_frame`. The example has three steps in z.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; steps_per_frame = metadata.get_n_averaging()</span>
<span class="sd">    &gt;&gt;&gt; steps_per_frame</span>
<span class="sd">    10</span>
<span class="sd">    &gt;&gt;&gt; processed_frame_counter = utils2p.synchronization.process_frame_counter(frame_counter, steps_per_frame=steps_per_frame)</span>
<span class="sd">    &gt;&gt;&gt; set(processed_frame_counter)</span>
<span class="sd">    {0, 1, 2, -9223372036854775808}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps_per_frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;metadata argument will be ignored &quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;because steps_per_frame argument was set.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">main</span><span class="o">.</span><span class="n">Metadata</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;metadata argument must be of type utils2p.Metadata or None.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">steps_per_frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">steps_per_frame</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;steps_per_frame has to be of type int&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps_per_frame</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;Streaming&quot;</span><span class="p">,</span> <span class="s2">&quot;zFastEnable&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
            <span class="n">steps_per_frame</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">steps_per_frame</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_n_z</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;Streaming&quot;</span><span class="p">,</span> <span class="s2">&quot;enable&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
                <span class="n">steps_per_frame</span> <span class="o">+=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_n_flyback_frames</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span>
                <span class="s2">&quot;LSM&quot;</span><span class="p">,</span>
                <span class="s2">&quot;averageMode&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span> <span class="ow">and</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_area_mode</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="s2">&quot;line&quot;</span><span class="p">,</span> <span class="s2">&quot;kymograph&quot;</span>
                <span class="p">]:</span>
            <span class="n">steps_per_frame</span> <span class="o">=</span> <span class="n">steps_per_frame</span> <span class="o">*</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_n_averaging</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">steps_per_frame</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If no metadata object is given, &quot;</span> <span class="o">+</span>
                         <span class="s2">&quot;the steps_per_frame argument has to be set.&quot;</span><span class="p">)</span>

    <span class="n">processed_frame_counter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">rising_edges</span> <span class="o">=</span> <span class="n">edges</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Case of one frame/volume only</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rising_edges</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">steps_per_frame</span><span class="p">:</span>
        <span class="n">processed_frame_counter</span><span class="p">[</span><span class="n">rising_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">processed_frame_counter</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                  <span class="nb">len</span><span class="p">(</span><span class="n">rising_edges</span><span class="p">)</span> <span class="o">-</span> <span class="n">steps_per_frame</span><span class="p">,</span> <span class="n">steps_per_frame</span><span class="p">)):</span>
        <span class="n">processed_frame_counter</span><span class="p">[</span>
            <span class="n">rising_edges</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span><span class="n">rising_edges</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">steps_per_frame</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">processed_frame_counter</span><span class="p">[</span><span class="n">rising_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">steps_per_frame</span><span class="p">]:]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">processed_frame_counter</span><span class="p">[</span><span class="n">rising_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">steps_per_frame</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">processed_frame_counter</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_stimulus_line"><a class="viewcode-back" href="../../loading_preprocessing.html#utils2p.synchronization.process_stimulus_line">[docs]</a><span class="k">def</span> <span class="nf">process_stimulus_line</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function converts the stimulus line to an array with</span>
<span class="sd">    0s and 1s for stimulus off and on respectively. The raw</span>
<span class="sd">    stimulus line can contain values larger than 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line : numpy array</span>
<span class="sd">        Line signal from h5 file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    processed_frame_counter : numpy array</span>
<span class="sd">        Array with binary stimulus state for each time point.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; h5_file = utils2p.find_sync_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &gt;&gt;&gt; line_names = [&quot;CO2_Stim&quot;]</span>
<span class="sd">    &gt;&gt;&gt; (stimulus_line,) = utils2p.synchronization.get_lines_from_h5_file(h5_file, line_names)</span>
<span class="sd">    &gt;&gt;&gt; set(stimulus_line)</span>
<span class="sd">    {0, 4}</span>
<span class="sd">    &gt;&gt;&gt; processed_stimulus_line = utils2p.synchronization.process_stimulus_line(stimulus_line)</span>
<span class="sd">    &gt;&gt;&gt; set(processed_stimulus_line)</span>
<span class="sd">    {0, 1}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">processed_stimulus_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">line</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">processed_stimulus_line</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">processed_stimulus_line</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_optical_flow_line"><a class="viewcode-back" href="../../loading_preprocessing.html#utils2p.synchronization.process_optical_flow_line">[docs]</a><span class="k">def</span> <span class="nf">process_optical_flow_line</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function converts the optical flow line</span>
<span class="sd">    into a step function. The value corresponds</span>
<span class="sd">    to the index of optical flow value at this</span>
<span class="sd">    time point. If the value is -9223372036854775808, no optical flow</span>
<span class="sd">    value was recorded for this time point.</span>

<span class="sd">    Note: Due to the time it takes to transfer the data</span>
<span class="sd">    from the Arduino to the computer it is possible that</span>
<span class="sd">    the last optical flow data point is missing, i.e.</span>
<span class="sd">    the processed optical flow line indicates one more</span>
<span class="sd">    data point than the text file contains. This can be</span>
<span class="sd">    solved by cropping all lines before the acquisition</span>
<span class="sd">    of the last optical flow data point. Lines can be</span>
<span class="sd">    cropped with :func:`crop_lines`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line : numpy array</span>
<span class="sd">        Line signal for h5 file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    processed_optical_flow_line : numpy array</span>
<span class="sd">        Array with monotonically increasing step</span>
<span class="sd">        function.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; h5_file = utils2p.find_sync_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &gt;&gt;&gt; line_names = [&quot;OpFlow&quot;]</span>
<span class="sd">    &gt;&gt;&gt; (optical_flow_line,) = utils2p.synchronization.get_lines_from_h5_file(h5_file, line_names)</span>
<span class="sd">    &gt;&gt;&gt; set(optical_flow_line)</span>
<span class="sd">    {0, 16}</span>
<span class="sd">    &gt;&gt;&gt; processed_optical_flow_line = utils2p.synchronization.process_optical_flow_line(optical_flow_line)</span>
<span class="sd">    &gt;&gt;&gt; len(set(processed_optical_flow_line))</span>
<span class="sd">    1409</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">processed_optical_flow_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">rising_edges</span> <span class="o">=</span> <span class="n">edges</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rising_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">processed_optical_flow_line</span><span class="p">[</span><span class="n">rising_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">rising_edges</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">processed_optical_flow_line</span><span class="p">[</span><span class="n">rising_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">processed_optical_flow_line</span><span class="p">[</span><span class="n">rising_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">processed_optical_flow_line</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="crop_lines"><a class="viewcode-back" href="../../misc_sync.html#utils2p.synchronization.crop_lines">[docs]</a><span class="k">def</span> <span class="nf">crop_lines</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function crops all lines based on a binary signal/mask.</span>
<span class="sd">    The &#39;Capture On&#39; line of the h5 file can be used as a mask.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mask : numpy array</span>
<span class="sd">        Mask that is used for cropping.</span>
<span class="sd">    lines : list of numpy arrays</span>
<span class="sd">        List of the lines that should be cropped.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cropped_lines : tuple of numpy arrays</span>
<span class="sd">        Tuple of cropped lines in same order as in input list.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; h5_file = utils2p.find_sync_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &gt;&gt;&gt; line_names = [&quot;Frame Counter&quot;, &quot;Capture On&quot;, &quot;CO2_Stim&quot;, &quot;OpFlow&quot;]</span>
<span class="sd">    &gt;&gt;&gt; (frame_counter, capture_on, stimulus_line, optical_flow_line,) = utils2p.synchronization.get_lines_from_h5_file(h5_file, line_names)</span>
<span class="sd">    &gt;&gt;&gt; frame_counter = utils2p.synchronization.process_frame_counter(frame_counter, steps_per_frame=4)</span>
<span class="sd">    &gt;&gt;&gt; len(frame_counter), len(capture_on), len(stimulus_line), len(optical_flow_line)</span>
<span class="sd">    (117000, 117000, 117000, 117000)</span>
<span class="sd">    &gt;&gt;&gt; mask = np.logical_and(frame_counter &gt;= 0, capture_on)</span>
<span class="sd">    &gt;&gt;&gt; np.sum(mask)</span>
<span class="sd">    105869</span>
<span class="sd">    &gt;&gt;&gt; (frame_counter, capture_on, stimulus_line, optical_flow_line,) = utils2p.synchronization.crop_lines(mask, (frame_counter, capture_on, stimulus_line, optical_flow_line,))</span>
<span class="sd">    &gt;&gt;&gt; len(frame_counter), len(capture_on), len(stimulus_line), len(optical_flow_line)</span>
<span class="sd">    (105869, 105869, 105869, 105869)</span>
<span class="sd">    &gt;&gt;&gt; line = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; mask = np.ones(10, dtype=np.bool)</span>
<span class="sd">    &gt;&gt;&gt; mask[0] = False</span>
<span class="sd">    &gt;&gt;&gt; mask[-1] = False</span>
<span class="sd">    &gt;&gt;&gt; mask[4] = False</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.crop_lines(mask, (line,))</span>
<span class="sd">    (array([1, 2, 3, 4, 5, 6, 7, 8]),)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">first_idx</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">last_idx</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cropped_lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="n">cropped_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">first_idx</span><span class="p">:</span><span class="n">last_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cropped_lines</span><span class="p">)</span></div>


<div class="viewcode-block" id="beh_idx_to_2p_idx"><a class="viewcode-back" href="../../conversion.html#utils2p.synchronization.beh_idx_to_2p_idx">[docs]</a><span class="k">def</span> <span class="nf">beh_idx_to_2p_idx</span><span class="p">(</span><span class="n">beh_indices</span><span class="p">,</span> <span class="n">cam_line</span><span class="p">,</span> <span class="n">frame_counter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This functions converts behaviour frame numbers into the corresponding</span>
<span class="sd">    2p frame numbers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    beh_indices : numpy array</span>
<span class="sd">        Indices of the behaviour frames to be converted.</span>
<span class="sd">    cam_line : numpy array</span>
<span class="sd">        Processed cam line.</span>
<span class="sd">    frame_counter : numpy array</span>
<span class="sd">        Processed frame counter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices_2p : numpy array</span>
<span class="sd">        Corresponding 2p frame indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; h5_file = utils2p.find_sync_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &gt;&gt;&gt; line_names = [&quot;Frame Counter&quot;, &quot;Basler&quot;]</span>
<span class="sd">    &gt;&gt;&gt; (frame_counter, cam_line,) = utils2p.synchronization.get_lines_from_h5_file(h5_file, line_names)</span>
<span class="sd">    &gt;&gt;&gt; frame_counter = utils2p.synchronization.process_frame_counter(frame_counter, steps_per_frame=4)</span>
<span class="sd">    &gt;&gt;&gt; seven_camera_metadata = utils2p.find_seven_camera_metadata_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &gt;&gt;&gt; cam_line = utils2p.synchronization.process_cam_line(cam_line, seven_camera_metadata)</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.beh_idx_to_2p_idx(np.array([0,]), cam_line, frame_counter)</span>
<span class="sd">    array([-9223372036854775808])</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.beh_idx_to_2p_idx(np.array([10,]), cam_line, frame_counter)</span>
<span class="sd">    array([0])</span>
<span class="sd">    &gt;&gt;&gt; utils2p.synchronization.beh_idx_to_2p_idx(np.arange(30), cam_line, frame_counter)</span>
<span class="sd">    array([-9223372036854775808,                    0,                    0,</span>
<span class="sd">                              0,                    0,                    0,</span>
<span class="sd">                              0,                    0,                    0,</span>
<span class="sd">                              0,                    0,                    0,</span>
<span class="sd">                              0,                    0,                    0,</span>
<span class="sd">                              0,                    0,                    0,</span>
<span class="sd">                              0,                    0,                    0,</span>
<span class="sd">                              0,                    1,                    1,</span>
<span class="sd">                              1,                    1,                    1,</span>
<span class="sd">                              1,                    1,                    1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">thor_sync_indices</span> <span class="o">=</span> <span class="n">edges</span><span class="p">(</span><span class="n">cam_line</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cam_line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">thor_sync_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">thor_sync_indices</span><span class="p">)</span>

    <span class="n">indices_2p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beh_indices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frame_num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">beh_indices</span><span class="p">):</span>
        <span class="n">thor_sync_index</span> <span class="o">=</span> <span class="n">thor_sync_indices</span><span class="p">[</span><span class="n">frame_num</span><span class="p">]</span>
        <span class="n">indices_2p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame_counter</span><span class="p">[</span><span class="n">thor_sync_index</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">indices_2p</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">reduce_during_2p_frame</span><span class="p">(</span><span class="n">frame_counter</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reduces all values occurring during the acquisition of a</span>
<span class="sd">    2-photon frame to a single value using the `function`</span>
<span class="sd">    given by the user.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frame_counter : numpy array</span>
<span class="sd">        Processed frame counter.</span>
<span class="sd">    values : numpy array</span>
<span class="sd">        Values upsampled to the frequency of ThorSync,</span>
<span class="sd">        i.e. 1D numpy array of the same length as</span>
<span class="sd">        `frame_counter`.</span>
<span class="sd">    function : function</span>
<span class="sd">        Function used to reduce the value,</span>
<span class="sd">        e.g. np.mean.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reduced : numpy array</span>
<span class="sd">        Numpy array with value for each 2p frame.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; h5_file = utils2p.find_sync_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &gt;&gt;&gt; line_names = [&quot;Frame Counter&quot;, &quot;CO2_Stim&quot;]</span>
<span class="sd">    &gt;&gt;&gt; (frame_counter, stimulus_line,) = utils2p.synchronization.get_lines_from_h5_file(h5_file, line_names)</span>
<span class="sd">    &gt;&gt;&gt; frame_counter = utils2p.synchronization.process_frame_counter(frame_counter, steps_per_frame=1)</span>
<span class="sd">    &gt;&gt;&gt; stimulus_line = utils2p.synchronization.process_stimulus_line(stimulus_line)</span>
<span class="sd">    &gt;&gt;&gt; np.max(frame_counter)</span>
<span class="sd">    4</span>
<span class="sd">    &gt;&gt;&gt; stimulus_during_2p_frames = utils2p.synchronization.reduce_during_2p_frame(frame_counter, stimulus_line, np.mean)</span>
<span class="sd">    &gt;&gt;&gt; len(stimulus_during_2p_frames)</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; np.max(stimulus_during_2p_frames)</span>
<span class="sd">    0.7136134613556422</span>
<span class="sd">    &gt;&gt;&gt; stimulus_during_2p_frames = utils2p.synchronization.reduce_during_2p_frame(frame_counter, stimulus_line, np.max)</span>
<span class="sd">    &gt;&gt;&gt; len(stimulus_during_2p_frames)</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; set(stimulus_during_2p_frames)</span>
<span class="sd">    {0.0, 1.0}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;reduce_during_2p_frame is deprecated use reduce_during_frame instead&quot;</span><span class="p">,</span>
        <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reduce_during_frame</span><span class="p">(</span><span class="n">frame_counter</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>


<div class="viewcode-block" id="reduce_during_frame"><a class="viewcode-back" href="../../conversion.html#utils2p.synchronization.reduce_during_frame">[docs]</a><span class="k">def</span> <span class="nf">reduce_during_frame</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reduces all values occurring during the acquisition of a</span>
<span class="sd">    frame to a single value using the `function` given by the user.</span>
<span class="sd">    The line function should be of the resolution of</span>
<span class="sd">    the ThorSync ticks and have the frame index as values.</span>
<span class="sd">    Possible choices are the processed frame_counter line or the</span>
<span class="sd">    processed cam_line.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line : numpy array</span>
<span class="sd">        Line holding frame indices.</span>
<span class="sd">    values : numpy array</span>
<span class="sd">        Values upsampled to the frequency of ThorSync,</span>
<span class="sd">        i.e. 1D numpy array of the same length as</span>
<span class="sd">        `frame_counter`.</span>
<span class="sd">    function : function</span>
<span class="sd">        Function used to reduce the value,</span>
<span class="sd">        e.g. np.mean.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reduced : numpy array</span>
<span class="sd">        Numpy array with value for each 2p frame.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; h5_file = utils2p.find_sync_file(&quot;data/mouse_kidney_raw&quot;)</span>
<span class="sd">    &gt;&gt;&gt; line_names = [&quot;Frame Counter&quot;, &quot;CO2_Stim&quot;]</span>
<span class="sd">    &gt;&gt;&gt; (frame_counter, stimulus_line,) = utils2p.synchronization.get_lines_from_h5_file(h5_file, line_names)</span>
<span class="sd">    &gt;&gt;&gt; frame_counter = utils2p.synchronization.process_frame_counter(frame_counter, steps_per_frame=1)</span>
<span class="sd">    &gt;&gt;&gt; stimulus_line = utils2p.synchronization.process_stimulus_line(stimulus_line)</span>
<span class="sd">    &gt;&gt;&gt; np.max(frame_counter)</span>
<span class="sd">    4</span>
<span class="sd">    &gt;&gt;&gt; stimulus_during_2p_frames = utils2p.synchronization.reduce_during_frame(frame_counter, stimulus_line, np.mean)</span>
<span class="sd">    &gt;&gt;&gt; len(stimulus_during_2p_frames)</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; np.max(stimulus_during_2p_frames)</span>
<span class="sd">    0.7136134613556422</span>
<span class="sd">    &gt;&gt;&gt; stimulus_during_2p_frames = utils2p.synchronization.reduce_during_frame(frame_counter, stimulus_line, np.max)</span>
<span class="sd">    &gt;&gt;&gt; len(stimulus_during_2p_frames)</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; set(stimulus_during_2p_frames)</span>
<span class="sd">    {0.0, 1.0}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;line and values need to have the same length.&quot;</span><span class="p">)</span>

    <span class="n">thor_sync_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edges</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">starts</span> <span class="o">=</span> <span class="n">thor_sync_indices</span>
    <span class="n">stops</span> <span class="o">=</span> <span class="n">thor_sync_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">9223372036854775808</span><span class="p">:</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">starts</span>
        <span class="n">stops</span> <span class="o">=</span> <span class="p">(</span><span class="n">thor_sync_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">)</span> <span class="o">+</span> <span class="n">stops</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">object</span>
    <span class="n">reduced</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">starts</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">stops</span><span class="p">)):</span>
        <span class="n">reduced</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">reduced</span></div>


<div class="viewcode-block" id="SyncMetadata"><a class="viewcode-back" href="../../misc_sync.html#utils2p.synchronization.SyncMetadata">[docs]</a><span class="k">class</span> <span class="nc">SyncMetadata</span><span class="p">(</span><span class="n">main</span><span class="o">.</span><span class="n">_XMLFile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for managing ThorSync metadata.</span>
<span class="sd">    Loads metadata file &#39;ThorRealTimeDataSettings.xml&#39;</span>
<span class="sd">    and returns the root of an ElementTree.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : string</span>
<span class="sd">        Path to xml file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Instance of class Metadata</span>
<span class="sd">        Based on given xml file.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; metadata = utils2p.synchronization.SyncMetadata(&quot;data/mouse_kidney_raw/2p/Sync-025/ThorRealTimeDataSettings.xml&quot;)</span>
<span class="sd">    &gt;&gt;&gt; type(metadata)</span>
<span class="sd">    &lt;class &#39;utils2p.synchronization.SyncMetadata&#39;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">get_active_devices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">active_devices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;DaqDevices&quot;</span><span class="p">,</span> <span class="s2">&quot;AcquireBoard&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">device</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;active&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
                <span class="n">active_devices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">active_devices</span>

    <span class="k">def</span> <span class="nf">get_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the frequency of the ThorSync</span>
<span class="sd">        value acquisition, i.e. the sample rate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        freq : integer</span>
<span class="sd">            Sample frequency in Hz.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">        &gt;&gt;&gt; metadata = utils2p.synchronization.SyncMetadata(&quot;data/mouse_kidney_raw/2p/Sync-025/ThorRealTimeDataSettings.xml&quot;)</span>
<span class="sd">        &gt;&gt;&gt; metadata.get_freq()</span>
<span class="sd">        30000</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sample_rate</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_devices</span><span class="p">():</span>
            <span class="n">set_for_device</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">device</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;SampleRate&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;enable&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">set_for_device</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Invalid metadata file. Multiple sample rates &quot;</span> <span class="o">+</span>
                            <span class="sa">f</span><span class="s2">&quot;are enabled for device </span><span class="si">{</span><span class="n">device</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">sample_rate</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multiple devices are enabled.&quot;</span><span class="p">)</span>
                    <span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;rate&quot;</span><span class="p">])</span>
                    <span class="n">set_for_device</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">sample_rate</span></div>


<div class="viewcode-block" id="get_processed_lines"><a class="viewcode-back" href="../../loading_preprocessing.html#utils2p.synchronization.get_processed_lines">[docs]</a><span class="k">def</span> <span class="nf">get_processed_lines</span><span class="p">(</span><span class="n">sync_file</span><span class="p">,</span>
                        <span class="n">sync_metadata_file</span><span class="p">,</span>
                        <span class="n">metadata_2p_file</span><span class="p">,</span>
                        <span class="n">seven_camera_metadata_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function extracts all the standard lines and processes them.</span>
<span class="sd">    It works for both microscopes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sync_file : str</span>
<span class="sd">        Path to the synchronization file.</span>
<span class="sd">    sync_metadata_file : str</span>
<span class="sd">        Path to the synchronization metadata file.</span>
<span class="sd">    metadata_2p_file : str</span>
<span class="sd">        Path to the ThorImage metadata file.</span>
<span class="sd">    seven_camera_metadata_file : str</span>
<span class="sd">        Path to the metadata file of the 7 camera system.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    processed_lines : dictionary</span>
<span class="sd">        Dictionary with all processed lines.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import utils2p</span>
<span class="sd">    &gt;&gt;&gt; import utils2p.synchronization</span>
<span class="sd">    &gt;&gt;&gt; experiment_dir = &quot;data/mouse_kidney_raw/&quot;</span>
<span class="sd">    &gt;&gt;&gt; sync_file = utils2p.find_sync_file(experiment_dir)</span>
<span class="sd">    &gt;&gt;&gt; metadata_file = utils2p.find_metadata_file(experiment_dir)</span>
<span class="sd">    &gt;&gt;&gt; sync_metadata_file = utils2p.find_sync_metadata_file(experiment_dir)</span>
<span class="sd">    &gt;&gt;&gt; seven_camera_metadata_file = utils2p.find_seven_camera_metadata_file(experiment_dir)</span>
<span class="sd">    &gt;&gt;&gt; processed_lines = utils2p.synchronization.processed_lines(sync_file, sync_metadata_file, metadata_file, seven_camera_metadata_file)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">processed_lines</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;Capture On&quot;</span><span class="p">],</span> <span class="n">processed_lines</span><span class="p">[</span>
        <span class="s2">&quot;Frame Counter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_lines_from_sync_file</span><span class="p">(</span>
            <span class="n">sync_file</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;Capture On&quot;</span><span class="p">,</span> <span class="s2">&quot;Frame Counter&quot;</span><span class="p">])</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># For microscope 1</span>
        <span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;CO2&quot;</span><span class="p">],</span> <span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;Cameras&quot;</span><span class="p">],</span> <span class="n">processed_lines</span><span class="p">[</span>
            <span class="s2">&quot;Optical flow&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_lines_from_sync_file</span><span class="p">(</span><span class="n">sync_file</span><span class="p">,</span> <span class="p">[</span>
                <span class="s2">&quot;CO2_Stim&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Basler&quot;</span><span class="p">,</span>
                <span class="s2">&quot;OpFlow&quot;</span><span class="p">,</span>
            <span class="p">])</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1"># For microscope 2</span>
        <span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;CO2&quot;</span><span class="p">],</span> <span class="n">processed_lines</span><span class="p">[</span>
            <span class="s2">&quot;Cameras&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_lines_from_h5_file</span><span class="p">(</span><span class="n">sync_file</span><span class="p">,</span> <span class="p">[</span>
                <span class="s2">&quot;CO2&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Cameras&quot;</span><span class="p">,</span>
            <span class="p">])</span>

    <span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;Cameras&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_cam_line</span><span class="p">(</span><span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;Cameras&quot;</span><span class="p">],</span>
                                                  <span class="n">seven_camera_metadata_file</span><span class="p">)</span>

    <span class="n">metadata_2p</span> <span class="o">=</span> <span class="n">main</span><span class="o">.</span><span class="n">Metadata</span><span class="p">(</span><span class="n">metadata_2p_file</span><span class="p">)</span>
    <span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;Frame Counter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_frame_counter</span><span class="p">(</span>
        <span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;Frame Counter&quot;</span><span class="p">],</span> <span class="n">metadata_2p</span><span class="p">)</span>

    <span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;CO2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_stimulus_line</span><span class="p">(</span><span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;CO2&quot;</span><span class="p">])</span>

    <span class="k">if</span> <span class="s2">&quot;Optical flow&quot;</span> <span class="ow">in</span> <span class="n">processed_lines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;Optical flow&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_optical_flow_line</span><span class="p">(</span>
            <span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;Optical flow&quot;</span><span class="p">])</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;Capture On&quot;</span><span class="p">],</span>
                          <span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;Frame Counter&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Make sure the clipping start just before the</span>
    <span class="c1"># acquisition of the first frame</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mask</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">line_name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">processed_lines</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">processed_lines</span><span class="p">[</span><span class="n">line_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">crop_lines</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">[</span>
            <span class="n">processed_lines</span><span class="p">[</span><span class="n">line_name</span><span class="p">],</span>
        <span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Get times of ThorSync ticks</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">SyncMetadata</span><span class="p">(</span><span class="n">sync_metadata_file</span><span class="p">)</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get_freq</span><span class="p">()</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">get_times</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;Frame Counter&quot;</span><span class="p">]),</span> <span class="n">freq</span><span class="p">)</span>
    <span class="n">processed_lines</span><span class="p">[</span><span class="s2">&quot;Times&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">times</span>

    <span class="k">return</span> <span class="n">processed_lines</span></div>


<div class="viewcode-block" id="epoch_length_filter"><a class="viewcode-back" href="../../misc_sync.html#utils2p.synchronization.epoch_length_filter">[docs]</a><span class="k">def</span> <span class="nf">epoch_length_filter</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">cut_off</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function filters a binary based on the length</span>
<span class="sd">    of each event.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line : numpy array of type bool</span>
<span class="sd">        Binary trace that is filtered.</span>
<span class="sd">    cut_off : int</span>
<span class="sd">        The minimal event length. All event shorter</span>
<span class="sd">        than `cut_off` are set to `False`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    filtered : numpy array of type bool</span>
<span class="sd">        The filtered binary trace.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">rising_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">falling_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">epoch_length</span> <span class="o">=</span> <span class="n">falling_edges</span> <span class="o">-</span> <span class="n">rising_edges</span>

    <span class="n">discarded_epochs</span> <span class="o">=</span> <span class="p">(</span><span class="n">epoch_length</span> <span class="o">&lt;</span> <span class="n">cut_off</span><span class="p">)</span>

    <span class="n">discarded_rising_edges</span> <span class="o">=</span> <span class="n">rising_edges</span><span class="p">[</span><span class="n">discarded_epochs</span><span class="p">]</span>
    <span class="n">discarded_falling_edges</span> <span class="o">=</span> <span class="n">falling_edges</span><span class="p">[</span><span class="n">discarded_epochs</span><span class="p">]</span>

    <span class="n">filtered</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">discarded_rising_edges</span><span class="p">,</span> <span class="n">discarded_falling_edges</span><span class="p">):</span>
        <span class="n">filtered</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">filtered</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_odor_line"><a class="viewcode-back" href="../../loading_preprocessing.html#utils2p.synchronization.process_odor_line">[docs]</a><span class="k">def</span> <span class="nf">process_odor_line</span><span class="p">(</span><span class="n">line</span><span class="p">,</span>
                      <span class="n">freq</span><span class="o">=</span><span class="mi">30000</span><span class="p">,</span>
                      <span class="n">arduino_commands</span><span class="o">=</span><span class="p">(</span>
                          <span class="s2">&quot;None&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Odor1&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Odor2&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Odor3&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Odor4&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Odor5&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Odor6&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Odor1R&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Odor2R&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Odor1L&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Odor2L&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Odor1B&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Odor2B&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;WaterB&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;bubbleMFC_R0&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;MFC1_R2&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;MFC2_L1&quot;</span><span class="p">,</span>
                      <span class="p">),</span>
                      <span class="n">step_size</span><span class="o">=</span><span class="mf">0.2703</span><span class="p">,</span>
                      <span class="n">filter_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The odor line is based on a PWM signal for the Arduino controlling the</span>
<span class="sd">    valves. This function applies a Butterworth filter and converts the</span>
<span class="sd">    resulting voltages to level indices. The corresponding the setting of the</span>
<span class="sd">    valves are given by the `arduino_commands` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    line : numpy array</span>
<span class="sd">        Unprocessed odor line from h5 file.</span>
<span class="sd">    freq : int</span>
<span class="sd">        Frequency of ThorSync. Necessary for the Butterworth filter.</span>
<span class="sd">    arduino_commands : list of strings</span>
<span class="sd">        Description of the valve settings for commands sent to arduino.</span>
<span class="sd">        Note: The order matters since the serial communications between</span>
<span class="sd">        computer and Arduino is based on the index in the list.</span>
<span class="sd">        This index is converted to a PWM signal that is recorded by ThorSync.</span>
<span class="sd">    step_size : float</span>
<span class="sd">        The voltage step size between different levels of the PWM. This is used</span>
<span class="sd">        to convert the voltage to indices.</span>
<span class="sd">    filter_only : bool</span>
<span class="sd">        If `True`, only the filtered line is returned instead of the odors</span>
<span class="sd">        based on the `arduino_commands`. This is useful for determining</span>
<span class="sd">        the `step_size`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array of strings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
    <span class="n">filtered_line</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">filter_only</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">filtered_line</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">filtered_line</span> <span class="o">/</span> <span class="n">step_size</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span>
        <span class="n">filtered_mask</span> <span class="o">=</span> <span class="n">epoch_length_filter</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
        <span class="n">indices</span><span class="p">[</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">filtered_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arduino_commands</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="event_based_frame_indices"><a class="viewcode-back" href="../../misc_sync.html#utils2p.synchronization.event_based_frame_indices">[docs]</a><span class="k">def</span> <span class="nf">event_based_frame_indices</span><span class="p">(</span><span class="n">event_indicator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates frame indices based on events.</span>
<span class="sd">    Frames before an event have negative numbers.</span>
<span class="sd">    The event onset has frame number 0 and the frames</span>
<span class="sd">    count up for the duration of the event.</span>
<span class="sd">    To be able to distinguish multiple events in the</span>
<span class="sd">    `event_indicator` an array with event numbers is</span>
<span class="sd">    returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    event_indicator : numpy array of type bool</span>
<span class="sd">        True indicates some event happening.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    event_based_indices : numpy array of type int</span>
<span class="sd">        Event based indices as described above.</span>
<span class="sd">    event_number : numpy array of type int</span>
<span class="sd">        Array of the same length as `event_based_indices`</span>
<span class="sd">        counting the number of events in event indicator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">event_indicator</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">inv_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask</span>
    <span class="n">inv_mask</span> <span class="o">=</span> <span class="n">inv_mask</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="n">inv_mask</span> <span class="o">=</span> <span class="n">inv_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span>
        <span class="mi">0</span><span class="p">,</span>
    <span class="p">],</span> <span class="n">mask</span><span class="p">))</span>
    <span class="n">inv_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">inv_mask</span><span class="p">,</span> <span class="p">[</span>
        <span class="mi">0</span><span class="p">,</span>
    <span class="p">]))</span>

    <span class="n">event_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
    <span class="n">inv_event_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">inv_mask</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">inv_mask</span> <span class="o">=</span> <span class="n">inv_mask</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Count up from zero during the event</span>
    <span class="n">event_frame_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">inv_event_frame_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">inv_mask</span><span class="p">)</span>
    <span class="n">n_events</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">event_numbers</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_events</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">event_numbers</span> <span class="o">==</span> <span class="n">event</span><span class="p">)</span>
        <span class="n">event_frame_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_frame_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> \
            <span class="n">event_frame_indices</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">event_frame_indices</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Count down from zero before each event</span>
    <span class="n">n_inv_event</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">inv_event_numbers</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">inv_event</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_inv_event</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inv_event_numbers</span> <span class="o">==</span> <span class="n">inv_event</span><span class="p">)</span>
        <span class="n">inv_event_frame_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_event_frame_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> \
            <span class="n">inv_event_frame_indices</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">inv_event_frame_indices</span><span class="p">[</span><span class="o">~</span><span class="n">inv_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">inv_event_frame_indices</span> <span class="o">=</span> <span class="o">-</span><span class="n">inv_event_frame_indices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">event_frame_indices</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span> <span class="o">=</span> <span class="n">inv_event_frame_indices</span><span class="p">[</span>
        <span class="o">~</span><span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>

    <span class="n">event_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
        <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">event_frame_indices</span><span class="p">))),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1"># Make sure the last frames are not counted as the pre-event</span>
    <span class="c1"># frames of a new event</span>
    <span class="n">n_events</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">event_numbers</span><span class="p">)</span>
    <span class="n">last_event</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">event_numbers</span> <span class="o">==</span> <span class="n">n_events</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">event_frame_indices</span><span class="p">[</span><span class="n">last_event</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">event_numbers</span><span class="p">[</span><span class="n">last_event</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">event_frame_indices</span><span class="p">,</span> <span class="n">event_numbers</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">utils2p</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../main.html">Core functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../synchronization.html">Synchronization functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Florian Aymanns.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>